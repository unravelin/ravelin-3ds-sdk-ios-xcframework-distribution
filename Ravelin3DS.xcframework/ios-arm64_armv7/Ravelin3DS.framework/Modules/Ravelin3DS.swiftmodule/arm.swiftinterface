// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.5.1 effective-4.2 (swiftlang-1300.0.31.4 clang-1300.0.29.6)
// swift-module-flags: -target armv7-apple-ios10.0 -enable-objc-interop -enable-library-evolution -swift-version 4.2 -enforce-exclusivity=checked -O -module-name Ravelin3DS
import AdSupport
import CommonCrypto
import Compression
import CoreLocation
import Darwin
import Foundation
import LocalAuthentication
@_exported import Ravelin3DS
import Security
import Swift
import UIKit
import WebKit
import _Concurrency
public struct JWS {
  public let header: Ravelin3DS.JWSHeader
  public let payload: Ravelin3DS.Payload
  public let signature: Foundation.Data
  public var compactSerializedString: Swift.String {
    get
  }
  public var compactSerializedData: Foundation.Data {
    get
  }
  public init<KeyType>(header: Ravelin3DS.JWSHeader, payload: Ravelin3DS.Payload, signer: Ravelin3DS.Signer<KeyType>) throws
  public init(compactSerialization: Swift.String) throws
  public init(compactSerialization: Foundation.Data) throws
  @available(*, deprecated, message: "Use `isValid(for verifier:)` instead")
  public func isValid<KeyType>(for publicKey: KeyType) -> Swift.Bool
  @available(*, deprecated, message: "Use `validate(using verifier:)` instead")
  public func validate<KeyType>(with publicKey: KeyType) throws -> Ravelin3DS.JWS
  public func validate(using verifier: Ravelin3DS.Verifier) throws -> Ravelin3DS.JWS
  public func isValid(for verifier: Ravelin3DS.Verifier) -> Swift.Bool
}
extension Ravelin3DS.JWS : Ravelin3DS.CompactSerializable {
  public func serialize(to serializer: inout Ravelin3DS.CompactSerializer)
}
extension Ravelin3DS.JWS : Ravelin3DS.CompactDeserializable {
  public static var componentCount: Swift.Int {
    get
  }
  public init(from deserializer: Ravelin3DS.CompactDeserializer) throws
}
@objc(R3DS2ProgressDialog) public protocol R3DS2ProgressDialog {
  @objc func start()
  @objc func stop()
}
extension Ravelin3DS.Rabbit {
  convenience public init(key: Swift.String) throws
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
public typealias SymmetricKeyComponents = (Foundation.Data)
public protocol ExpressibleAsSymmetricKeyComponents {
  static func representing(symmetricKeyComponents components: Ravelin3DS.SymmetricKeyComponents) throws -> Self
  func symmetricKeyComponents() throws -> Ravelin3DS.SymmetricKeyComponents
}
public struct SymmetricKey : Ravelin3DS.JWK {
  public let keyType: Ravelin3DS.JWKKeyType
  public let parameters: [Swift.String : Swift.String]
  public var requiredParameters: [Swift.String : Swift.String] {
    get
  }
  public let key: Swift.String
  public init(key: Foundation.Data, additionalParameters parameters: [Swift.String : Swift.String] = [:])
  public init(key: Ravelin3DS.ExpressibleAsSymmetricKeyComponents, additionalParameters parameters: [Swift.String : Swift.String] = [:]) throws
  public init(data: Foundation.Data) throws
  public func converted<T>(to type: T.Type) throws -> T where T : Ravelin3DS.ExpressibleAsSymmetricKeyComponents
  @available(iOS 11.0, *)
  public func withThumbprintAsKeyId(algorithm: Ravelin3DS.JWKThumbprintAlgorithm = .SHA256) throws -> Ravelin3DS.SymmetricKey
}
extension Security.SecKey : Ravelin3DS.ExpressibleAsECPublicKeyComponents {
  public static func representing(ecPublicKeyComponents components: Ravelin3DS.ECPublicKeyComponents) throws -> Self
  public func ecPublicKeyComponents() throws -> Ravelin3DS.ECPublicKeyComponents
}
public struct RAV3DS2Config : Swift.Codable {
  public func jsonData() throws -> Foundation.Data
  public func params() -> [Swift.String : Any]?
  public func with(logLevel: Swift.String, schemes: [Ravelin3DS.RAV3DS2Scheme]) -> Ravelin3DS.RAV3DS2Config
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct RAV3DS2Scheme : Swift.Codable {
  public func with(name: Swift.String, logoImageName: Swift.String, ids: [Swift.String]? = nil, encryptionKeyValue: Swift.String, rootCertificate: Swift.String? = nil, timeoutMinutes: Swift.String? = nil) -> Ravelin3DS.RAV3DS2Scheme
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class ScrollingStackViewController : UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) final public let scrollView: UIKit.UIScrollView
  @_Concurrency.MainActor(unsafe) final public let stackViewBackgroundView: UIKit.UIView
  @_Concurrency.MainActor(unsafe) final public let stackView: UIKit.UIStackView
  @_Concurrency.MainActor(unsafe) public var spacingColor: UIKit.UIColor {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var borderColor: UIKit.UIColor {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var borderWidth: CoreGraphics.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public static func defaultAnimate(_ animations: @escaping () -> (), completion: ((Swift.Bool) -> Swift.Void)?)
  @_Concurrency.MainActor(unsafe) public var animate: (@escaping () -> (), ((Swift.Bool) -> Swift.Void)?) -> ()
  @_Concurrency.MainActor(unsafe) public static func defaultScrollAnimate(_ animations: @escaping () -> (), completion: ((Swift.Bool) -> Swift.Void)?)
  @_Concurrency.MainActor(unsafe) public var scrollAnimate: (@escaping () -> (), ((Swift.Bool) -> Swift.Void)?) -> ()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewDidLayoutSubviews()
  @_Concurrency.MainActor(unsafe) open func add(viewController: UIKit.UIViewController)
  @_Concurrency.MainActor(unsafe) open func add(viewController: UIKit.UIViewController, edgeInsets: UIKit.UIEdgeInsets)
  @_Concurrency.MainActor(unsafe) open func insert(viewController: UIKit.UIViewController, at index: Swift.Int)
  @_Concurrency.MainActor(unsafe) open func insert(viewController: UIKit.UIViewController, edgeInsets: UIKit.UIEdgeInsets, at index: Swift.Int)
  @_Concurrency.MainActor(unsafe) open func remove(viewController: UIKit.UIViewController)
  @_Concurrency.MainActor(unsafe) open func show(viewController: UIKit.UIViewController, _ action: (() -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) open func hide(viewController: UIKit.UIViewController, _ action: (() -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) open func scrollTo(viewController: UIKit.UIViewController, _ action: (() -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public struct CTR {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: Ravelin3DS.CTR.Error, b: Ravelin3DS.CTR.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: Ravelin3DS.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>, counter: Swift.Int = 0)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping Ravelin3DS.CipherOperationOnBlock, encryptionOperation: @escaping Ravelin3DS.CipherOperationOnBlock) throws -> Ravelin3DS.CipherModeWorker
}
@_inheritsConvenienceInitializers final public class CBCMAC : Ravelin3DS.CMAC {
  override final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  override public init(key: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
public enum CipherError : Swift.Error {
  case encrypt
  case decrypt
  public static func == (a: Ravelin3DS.CipherError, b: Ravelin3DS.CipherError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Cipher : AnyObject {
  var keySize: Swift.Int { get }
  func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension Ravelin3DS.Cipher {
  public func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
public struct Encrypter<KeyType> {
  public init?(keyManagementAlgorithm: Ravelin3DS.KeyManagementAlgorithm, contentEncryptionAlgorithm: Ravelin3DS.ContentEncryptionAlgorithm, encryptionKey: KeyType)
}
extension Ravelin3DS.Encrypter {
  @available(*, deprecated, message: "Use `init?(keyManagementAlgorithm:contentEncryptionAlgorithm:encryptionKey:)` instead")
  public init?(keyEncryptionAlgorithm: Ravelin3DS.AsymmetricKeyAlgorithm, encryptionKey key: KeyType, contentEncyptionAlgorithm: Ravelin3DS.SymmetricKeyAlgorithm)
  @available(*, deprecated, message: "Use `init?(keyManagementAlgorithm:contentEncryptionAlgorithm:encryptionKey:)` instead")
  public init?(keyEncryptionAlgorithm: Ravelin3DS.AsymmetricKeyAlgorithm, keyEncryptionKey kek: KeyType, contentEncyptionAlgorithm: Ravelin3DS.SymmetricKeyAlgorithm)
}
@available(*, deprecated, message: "This type will be removed with the next major release.")
public struct EncryptionContext {
}
@available(*, deprecated, message: "This type will be removed with the next major release.")
public struct SymmetricEncryptionContext {
}
extension Ravelin3DS.JWK {
  public subscript(parameter: Swift.String) -> Swift.String? {
    get
  }
}
extension Ravelin3DS.JWK {
  public func jsonString() -> Swift.String?
  public func jsonData() -> Foundation.Data?
}
extension Swift.Array where Element == Swift.UInt8 {
  public func toBase64() -> Swift.String
  public init(base64: Swift.String)
}
@objc(R3DS2Warning) @objcMembers public class R3DS2Warning : ObjectiveC.NSObject {
  @objc public init(warningId: Swift.String, message: Swift.String, severity: Ravelin3DS.R3DS2Severity)
  @objc public func getID() -> Swift.String
  @objc public func getMessage() -> Swift.String
  @objc public func getSeverity() -> Ravelin3DS.R3DS2Severity
  @objc deinit
}
extension Ravelin3DS.RSAPublicKey : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension Ravelin3DS.RSAPublicKey : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension Ravelin3DS.RSAPrivateKey : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension Ravelin3DS.RSAPrivateKey : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
public enum SecureRandomError : Swift.Error {
  case failed(status: Darwin.OSStatus)
  case countMustBeGreaterThanZero
}
public struct SecureRandom {
  public static func generate(count: Swift.Int) throws -> Foundation.Data
}
public enum JWKParameter : Swift.String, Swift.CodingKey {
  case keyType
  case keyUse
  case keyOperations
  case algorithm
  case keyIdentifier
  case X509URL
  case X509CertificateChain
  case X509CertificateSHA1Thumbprint
  case X509CertificateSHA256Thumbprint
  public init?(stringValue: Swift.String)
  public init?(intValue: Swift.Int)
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var intValue: Swift.Int? {
    get
  }
  public var rawValue: Swift.String {
    get
  }
  public var stringValue: Swift.String {
    get
  }
}
public enum RSAParameter : Swift.String, Swift.CodingKey {
  case modulus
  case exponent
  case privateExponent
  public init?(rawValue: Swift.String)
  public init?(stringValue: Swift.String)
  public init?(intValue: Swift.Int)
  public typealias RawValue = Swift.String
  public var intValue: Swift.Int? {
    get
  }
  public var rawValue: Swift.String {
    get
  }
  public var stringValue: Swift.String {
    get
  }
}
public enum SymmetricKeyParameter : Swift.String, Swift.CodingKey {
  case key
  public init?(rawValue: Swift.String)
  public init?(stringValue: Swift.String)
  public init?(intValue: Swift.Int)
  public typealias RawValue = Swift.String
  public var intValue: Swift.Int? {
    get
  }
  public var rawValue: Swift.String {
    get
  }
  public var stringValue: Swift.String {
    get
  }
}
public enum ECParameter : Swift.String, Swift.CodingKey {
  case curve
  case x
  case y
  case privateKey
  public init?(rawValue: Swift.String)
  public init?(stringValue: Swift.String)
  public init?(intValue: Swift.Int)
  public typealias RawValue = Swift.String
  public var intValue: Swift.Int? {
    get
  }
  public var rawValue: Swift.String {
    get
  }
  public var stringValue: Swift.String {
    get
  }
}
extension Foundation.Data : Ravelin3DS.ExpressibleAsRSAPublicKeyComponents {
  public static func representing(rsaPublicKeyComponents components: Ravelin3DS.RSAPublicKeyComponents) throws -> Foundation.Data
  public func rsaPublicKeyComponents() throws -> Ravelin3DS.RSAPublicKeyComponents
}
public struct Payload : Ravelin3DS.DataConvertible {
  public init(_ payload: Foundation.Data)
  public func data() -> Foundation.Data
}
@_inheritsConvenienceInitializers @objc(R3DS2ButtonCustomization) @objcMembers public class R3DS2ButtonCustomization : Ravelin3DS.R3DS2Customization {
  @objc public func setBackgroundColor(hexColorCode: Swift.String) throws
  @objc public func setDarkBackgroundColor(hexColorCode: Swift.String) throws
  @objc public func setCornerRadius(cornerRadius: Swift.Int) throws
  @objc public func getBackgroundColor() -> Swift.String
  @objc public func getDarkBackgroundColor() -> Swift.String
  @objc public func getCornerRadius() -> Swift.Int
  @objc override public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  @objc override dynamic public init()
  @objc deinit
}
@objc(R3DS2ChallengeView) public protocol R3DS2ChallengeView {
  @objc var viewController: UIKit.UIViewController { get }
}
extension Ravelin3DS.HMAC {
  convenience public init(key: Swift.String, variant: Ravelin3DS.HMAC.Variant = .md5) throws
}
@_inheritsConvenienceInitializers @objc(R3DS2ConfigParameters) @objcMembers public class R3DS2ConfigParameters : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc public func addParam(group: Swift.String? = nil, paramName: Swift.String, paramValue: Swift.String) throws
  public func getParamValue(group: Swift.String? = nil, paramName: Swift.String) throws -> Swift.String?
  public func removeParam(group: Swift.String? = nil, paramName: Swift.String) throws -> Swift.String?
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class AEADChaCha20Poly1305 : Ravelin3DS.AEAD {
  public static let kLen: Swift.Int
  public static var ivRange: Swift.Range<Swift.Int>
  public static func encrypt(_ plainText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>) throws -> (cipherText: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>)
  public static func decrypt(_ cipherText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>) throws -> (plainText: Swift.Array<Swift.UInt8>, success: Swift.Bool)
  @objc deinit
}
public enum SignatureAlgorithm : Swift.String {
  case HS256
  case HS384
  case HS512
  case RS256
  case RS384
  case RS512
  @available(iOS 11, *)
  case PS256
  @available(iOS 11, *)
  case PS384
  @available(iOS 11, *)
  case PS512
  case ES256
  case ES384
  case ES512
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum KeyManagementAlgorithm : Swift.String, Swift.CaseIterable {
  case RSA1_5
  case RSAOAEP
  case RSAOAEP256
  case A128KW
  case A192KW
  case A256KW
  case direct
  public init?(rawValue: Swift.String)
  public typealias AllCases = [Ravelin3DS.KeyManagementAlgorithm]
  public typealias RawValue = Swift.String
  public static var allCases: [Ravelin3DS.KeyManagementAlgorithm] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum ContentEncryptionAlgorithm : Swift.String {
  case A256CBCHS512
  case A128CBCHS256
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum HMACAlgorithm : Swift.String {
  case SHA512
  case SHA384
  case SHA256
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum JWKThumbprintAlgorithm : Swift.String {
  case SHA256
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum CompressionAlgorithm : Swift.String {
  case DEFLATE
  case NONE
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@available(*, deprecated, message: "Use `KeyManagementAlgorithm` instead")
public typealias AsymmetricKeyAlgorithm = Ravelin3DS.KeyManagementAlgorithm
@available(*, deprecated, message: "Use `ContentEncryptionAlgorithm` instead")
public typealias SymmetricKeyAlgorithm = Ravelin3DS.ContentEncryptionAlgorithm
@_inheritsConvenienceInitializers @objc(R3DS2Customization) @objcMembers public class R3DS2Customization : ObjectiveC.NSObject, Foundation.NSCopying {
  @objc convenience public init(with base: Ravelin3DS.R3DS2Customization)
  @objc public func setTextFontName(fontName: Swift.String) throws
  @objc public func setTextColor(hexColorCode: Swift.String) throws
  @objc public func setDarkTextColor(hexColorCode: Swift.String) throws
  @objc public func setTextFontSize(fontSize: Swift.Int) throws
  @objc public func getTextFontName() -> Swift.String
  @objc public func getTextColor() -> Swift.String
  @objc public func getDarkTextColor() -> Swift.String
  @objc public func getTextFontSize() -> Swift.Int
  @objc public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  @objc override dynamic public init()
  @objc deinit
}
extension Foundation.Data {
  public func checksum() -> Swift.UInt16
  public func md5() -> Foundation.Data
  public func sha1() -> Foundation.Data
  public func sha224() -> Foundation.Data
  public func sha256() -> Foundation.Data
  public func sha384() -> Foundation.Data
  public func sha512() -> Foundation.Data
  public func sha3(_ variant: Ravelin3DS.SHA3.Variant) -> Foundation.Data
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc16(seed: Swift.UInt16? = nil) -> Foundation.Data
  public func encrypt(cipher: Ravelin3DS.Cipher) throws -> Foundation.Data
  public func decrypt(cipher: Ravelin3DS.Cipher) throws -> Foundation.Data
  public func authenticate(with authenticator: Ravelin3DS.Authenticator) throws -> Foundation.Data
}
extension Foundation.Data {
  public init(hex: Swift.String)
  public var bytes: Swift.Array<Swift.UInt8> {
    get
  }
  public func toHexString() -> Swift.String
}
extension UIKit.UIColor {
  convenience public init?(hexColorCode: Swift.String)
}
public struct JWEHeader {
  public init(keyManagementAlgorithm: Ravelin3DS.KeyManagementAlgorithm, contentEncryptionAlgorithm: Ravelin3DS.ContentEncryptionAlgorithm)
  public init(parameters: [Swift.String : Any]) throws
}
extension Ravelin3DS.JWEHeader {
  public var keyManagementAlgorithm: Ravelin3DS.KeyManagementAlgorithm? {
    get
  }
  public var contentEncryptionAlgorithm: Ravelin3DS.ContentEncryptionAlgorithm? {
    get
  }
  public var compressionAlgorithm: Ravelin3DS.CompressionAlgorithm? {
    get
  }
  public var zip: Swift.String? {
    get
    set
  }
}
extension Ravelin3DS.JWEHeader : Ravelin3DS.CommonHeaderParameterSpace {
  public var jku: Foundation.URL? {
    get
    set
  }
  public var jwk: Swift.String? {
    get
    set
  }
  public var jwkTyped: Ravelin3DS.JWK? {
    get
    set
  }
  public var kid: Swift.String? {
    get
    set
  }
  public var x5u: Foundation.URL? {
    get
    set
  }
  public var x5c: [Swift.String]? {
    get
    set
  }
  public var x5t: Swift.String? {
    get
    set
  }
  public var x5tS256: Swift.String? {
    get
    set
  }
  public var typ: Swift.String? {
    get
    set
  }
  public var cty: Swift.String? {
    get
    set
  }
  public var crit: [Swift.String]? {
    get
    set
  }
}
extension Ravelin3DS.JWEHeader {
  @available(*, deprecated, message: "Use `JWEHeader.keyManagementAlgorithm` instead")
  public var algorithm: Ravelin3DS.AsymmetricKeyAlgorithm? {
    get
  }
  @available(*, deprecated, message: "Use `JWEHeader.contentEncryptionAlgorithm` instead")
  public var encryptionAlgorithm: Ravelin3DS.SymmetricKeyAlgorithm? {
    get
  }
  @available(*, deprecated, message: "Use `init(keyManagementAlgorithm:contentEncryptionAlgorithm` instead")
  public init(algorithm: Ravelin3DS.AsymmetricKeyAlgorithm, encryptionAlgorithm: Ravelin3DS.SymmetricKeyAlgorithm)
}
final public class Blowfish {
  public enum Error : Swift.Error {
    case dataPaddingRequired
    case invalidKeyOrInitializationVector
    case invalidInitializationVector
    case invalidBlockMode
    public static func == (a: Ravelin3DS.Blowfish.Error, b: Ravelin3DS.Blowfish.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, blockMode: Ravelin3DS.BlockMode = CBC(iv: Array<UInt8>(repeating: 0, count: Blowfish.blockSize)), padding: Ravelin3DS.Padding) throws
  @objc deinit
}
extension Ravelin3DS.Blowfish : Ravelin3DS.Cipher {
  final public func encrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
  final public func decrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
}
final public class AES {
  public enum Error : Swift.Error {
    case invalidKeySize
    case dataPaddingRequired
    case invalidData
    public static func == (a: Ravelin3DS.AES.Error, b: Ravelin3DS.AES.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Variant : Swift.Int {
    case aes128, aes192, aes256
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @usableFromInline
  final internal let variantNr: Swift.Int
  @usableFromInline
  final internal let variantNb: Swift.Int
  @usableFromInline
  final internal let variantNk: Swift.Int
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  final public let variant: Ravelin3DS.AES.Variant
  @usableFromInline
  final internal let blockMode: Ravelin3DS.BlockMode
  @usableFromInline
  final internal let padding: Ravelin3DS.Padding
  @usableFromInline
  final internal var expandedKey: Swift.Array<Swift.Array<Swift.UInt32>> {
    get
    set
  }
  @usableFromInline
  final internal var expandedKeyInv: Swift.Array<Swift.Array<Swift.UInt32>> {
    get
    set
  }
  @usableFromInline
  internal static let T0: [Swift.UInt32]
  @usableFromInline
  internal static let T0_INV: [Swift.UInt32]
  @usableFromInline
  internal static let T1: [Swift.UInt32]
  @usableFromInline
  internal static let T1_INV: [Swift.UInt32]
  @usableFromInline
  internal static let T2: [Swift.UInt32]
  @usableFromInline
  internal static let T2_INV: [Swift.UInt32]
  @usableFromInline
  internal static let T3: [Swift.UInt32]
  @usableFromInline
  internal static let T3_INV: [Swift.UInt32]
  @usableFromInline
  internal static let U1: [Swift.UInt32]
  @usableFromInline
  internal static let U2: [Swift.UInt32]
  @usableFromInline
  internal static let U3: [Swift.UInt32]
  @usableFromInline
  internal static let U4: [Swift.UInt32]
  public init(key: Swift.Array<Swift.UInt8>, blockMode: Ravelin3DS.BlockMode, padding: Ravelin3DS.Padding = .pkcs7) throws
  @inlinable final internal func encrypt(block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>? {
    if self.blockMode.options.contains(.paddingRequired) && block.count != AES.blockSize {
      return Array(block)
    }

    let rounds = self.variantNr
    let rk = self.expandedKey

    let b00 = UInt32(block[block.startIndex.advanced(by: 0)])
    let b01 = UInt32(block[block.startIndex.advanced(by: 1)]) << 8
    let b02 = UInt32(block[block.startIndex.advanced(by: 2)]) << 16
    let b03 = UInt32(block[block.startIndex.advanced(by: 3)]) << 24
    var b0 = b00 | b01 | b02 | b03

    let b10 = UInt32(block[block.startIndex.advanced(by: 4)])
    let b11 = UInt32(block[block.startIndex.advanced(by: 5)]) << 8
    let b12 = UInt32(block[block.startIndex.advanced(by: 6)]) << 16
    let b13 = UInt32(block[block.startIndex.advanced(by: 7)]) << 24
    var b1 = b10 | b11 | b12 | b13

    let b20 = UInt32(block[block.startIndex.advanced(by: 8)])
    let b21 = UInt32(block[block.startIndex.advanced(by: 9)]) << 8
    let b22 = UInt32(block[block.startIndex.advanced(by: 10)]) << 16
    let b23 = UInt32(block[block.startIndex.advanced(by: 11)]) << 24
    var b2 = b20 | b21 | b22 | b23

    let b30 = UInt32(block[block.startIndex.advanced(by: 12)])
    let b31 = UInt32(block[block.startIndex.advanced(by: 13)]) << 8
    let b32 = UInt32(block[block.startIndex.advanced(by: 14)]) << 16
    let b33 = UInt32(block[block.startIndex.advanced(by: 15)]) << 24
    var b3 = b30 | b31 | b32 | b33

    let tLength = 4
    let t = UnsafeMutablePointer<UInt32>.allocate(capacity: tLength)
    t.initialize(repeating: 0, count: tLength)
    defer {
      t.deinitialize(count: tLength)
      t.deallocate()
    }

    for r in 0..<rounds - 1 {
      t[0] = b0 ^ rk[r][0]
      t[1] = b1 ^ rk[r][1]
      t[2] = b2 ^ rk[r][2]
      t[3] = b3 ^ rk[r][3]

      let lb00 = AES.T0[Int(t[0] & 0xff)]
      let lb01 = AES.T1[Int((t[1] >> 8) & 0xff)]
      let lb02 = AES.T2[Int((t[2] >> 16) & 0xff)]
      let lb03 = AES.T3[Int(t[3] >> 24)]
      b0 = lb00 ^ lb01 ^ lb02 ^ lb03

      let lb10 = AES.T0[Int(t[1] & 0xff)]
      let lb11 = AES.T1[Int((t[2] >> 8) & 0xff)]
      let lb12 = AES.T2[Int((t[3] >> 16) & 0xff)]
      let lb13 = AES.T3[Int(t[0] >> 24)]
      b1 = lb10 ^ lb11 ^ lb12 ^ lb13

      let lb20 = AES.T0[Int(t[2] & 0xff)]
      let lb21 = AES.T1[Int((t[3] >> 8) & 0xff)]
      let lb22 = AES.T2[Int((t[0] >> 16) & 0xff)]
      let lb23 = AES.T3[Int(t[1] >> 24)]
      b2 = lb20 ^ lb21 ^ lb22 ^ lb23

      let lb30 = AES.T0[Int(t[3] & 0xff)]
      let lb31 = AES.T1[Int((t[0] >> 8) & 0xff)]
      let lb32 = AES.T2[Int((t[1] >> 16) & 0xff)]
      let lb33 = AES.T3[Int(t[2] >> 24)]
      b3 = lb30 ^ lb31 ^ lb32 ^ lb33
    }

    // last round
    let r = rounds - 1

    t[0] = b0 ^ rk[r][0]
    t[1] = b1 ^ rk[r][1]
    t[2] = b2 ^ rk[r][2]
    t[3] = b3 ^ rk[r][3]

    // rounds
    b0 = F1(t[0], t[1], t[2], t[3]) ^ rk[rounds][0]
    b1 = F1(t[1], t[2], t[3], t[0]) ^ rk[rounds][1]
    b2 = F1(t[2], t[3], t[0], t[1]) ^ rk[rounds][2]
    b3 = F1(t[3], t[0], t[1], t[2]) ^ rk[rounds][3]

    let encrypted: Array<UInt8> = [
      UInt8(b0 & 0xff), UInt8((b0 >> 8) & 0xff), UInt8((b0 >> 16) & 0xff), UInt8((b0 >> 24) & 0xff),
      UInt8(b1 & 0xff), UInt8((b1 >> 8) & 0xff), UInt8((b1 >> 16) & 0xff), UInt8((b1 >> 24) & 0xff),
      UInt8(b2 & 0xff), UInt8((b2 >> 8) & 0xff), UInt8((b2 >> 16) & 0xff), UInt8((b2 >> 24) & 0xff),
      UInt8(b3 & 0xff), UInt8((b3 >> 8) & 0xff), UInt8((b3 >> 16) & 0xff), UInt8((b3 >> 24) & 0xff)
    ]
    return encrypted
  }
  @usableFromInline
  final internal func decrypt(block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>?
  @objc deinit
}
extension Ravelin3DS.AES {
  @usableFromInline
  @inline(__always) final internal func F1(_ x0: Swift.UInt32, _ x1: Swift.UInt32, _ x2: Swift.UInt32, _ x3: Swift.UInt32) -> Swift.UInt32
}
extension Ravelin3DS.AES : Ravelin3DS.Cipher {
  @inlinable final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    let blockSize = self.blockMode.customBlockSize ?? AES.blockSize
    let chunks = bytes.batched(by: blockSize)

    var oneTimeCryptor = try makeEncryptor()
    var out = Array<UInt8>(reserveCapacity: bytes.count)
    for chunk in chunks {
      out += try oneTimeCryptor.update(withBytes: chunk, isLast: false)
    }
    // Padding may be added at the very end
    out += try oneTimeCryptor.finish()

    if self.blockMode.options.contains(.paddingRequired) && (out.count % AES.blockSize != 0) {
      throw Error.dataPaddingRequired
    }

    return out
  }
  @inlinable final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    if self.blockMode.options.contains(.paddingRequired) && (bytes.count % AES.blockSize != 0) {
      throw Error.dataPaddingRequired
    }

    var oneTimeCryptor = try makeDecryptor()
    let chunks = bytes.batched(by: AES.blockSize)
    if chunks.isEmpty {
      throw Error.invalidData
    }

    var out = Array<UInt8>(reserveCapacity: bytes.count)

    var lastIdx = chunks.startIndex
    chunks.indices.formIndex(&lastIdx, offsetBy: chunks.count - 1)

    // To properly remove padding, `isLast` has to be known when called with the last chunk of ciphertext
    // Last chunk of ciphertext may contains padded data so next call to update(..) won't be able to remove it
    for idx in chunks.indices {
      out += try oneTimeCryptor.update(withBytes: chunks[idx], isLast: idx == lastIdx)
    }
    return out
  }
}
extension Ravelin3DS.SymmetricKey : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension Ravelin3DS.SymmetricKey : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
@available(*, renamed: "Digest")
public typealias Hash = Ravelin3DS.Digest
public struct Digest {
  public static func md5(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha1(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha224(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha256(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha384(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha512(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha2(_ bytes: Swift.Array<Swift.UInt8>, variant: Ravelin3DS.SHA2.Variant) -> Swift.Array<Swift.UInt8>
  public static func sha3(_ bytes: Swift.Array<Swift.UInt8>, variant: Ravelin3DS.SHA3.Variant) -> Swift.Array<Swift.UInt8>
}
final public class SHA3 {
  final public let blockSize: Swift.Int
  final public let digestLength: Swift.Int
  final public let markByte: Swift.UInt8
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var accumulatedHash: Swift.Array<Swift.UInt64>
  public enum Variant {
    case sha224, sha256, sha384, sha512, keccak224, keccak256, keccak384, keccak512
    public var outputLength: Swift.Int {
      get
    }
    public static func == (a: Ravelin3DS.SHA3.Variant, b: Ravelin3DS.SHA3.Variant) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(variant: Ravelin3DS.SHA3.Variant)
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  @usableFromInline
  final internal func process(block chunk: Swift.ArraySlice<Swift.UInt64>, currentHash hh: inout Swift.Array<Swift.UInt64>)
  @objc deinit
}
extension Ravelin3DS.SHA3 : Ravelin3DS.Updatable {
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      // Add padding
      let markByteIndex = self.accumulated.count

      // We need to always pad the input. Even if the input is a multiple of blockSize.
      let r = self.blockSize * 8
      let q = (r / 8) - (accumulated.count % (r / 8))
      self.accumulated += Array<UInt8>(repeating: 0, count: q)

      self.accumulated[markByteIndex] |= self.markByte
      self.accumulated[self.accumulated.count - 1] |= 0x80
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: self.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= self.blockSize {
        self.process(block: chunk.toUInt64Array().slice, currentHash: &self.accumulatedHash)
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)

    // TODO: verify performance, reduce vs for..in
    let result = self.accumulatedHash.reduce(into: Array<UInt8>()) { (result, value) in
      result += value.bigEndian.bytes()
    }

    // reset hash value for instance
    if isLast {
      self.accumulatedHash = Array<UInt64>(repeating: 0, count: self.digestLength)
    }

    return Array(result[0..<self.digestLength])
  }
}
@usableFromInline
final internal class BlockEncryptor : Ravelin3DS.Cryptor, Ravelin3DS.Updatable {
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: Ravelin3DS.Padding, _ worker: Ravelin3DS.CipherModeWorker) throws
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8>
  @usableFromInline
  final internal func seek(to: Swift.Int) throws
  @objc @usableFromInline
  deinit
}
@usableFromInline
internal struct BatchedCollectionIndex<Base> where Base : Swift.Collection {
}
extension Ravelin3DS.BatchedCollectionIndex : Swift.Comparable {
  @usableFromInline
  internal static func == <Base>(lhs: Ravelin3DS.BatchedCollectionIndex<Base>, rhs: Ravelin3DS.BatchedCollectionIndex<Base>) -> Swift.Bool where Base : Swift.Collection
  @usableFromInline
  internal static func < <Base>(lhs: Ravelin3DS.BatchedCollectionIndex<Base>, rhs: Ravelin3DS.BatchedCollectionIndex<Base>) -> Swift.Bool where Base : Swift.Collection
}
@usableFromInline
internal struct BatchedCollection<Base> : Swift.Collection where Base : Swift.Collection {
  @usableFromInline
  internal init(base: Base, size: Swift.Int)
  @usableFromInline
  internal typealias Index = Ravelin3DS.BatchedCollectionIndex<Base>
  @usableFromInline
  internal var startIndex: Ravelin3DS.BatchedCollection<Base>.Index {
    get
  }
  @usableFromInline
  internal var endIndex: Ravelin3DS.BatchedCollection<Base>.Index {
    get
  }
  @usableFromInline
  internal func index(after idx: Ravelin3DS.BatchedCollection<Base>.Index) -> Ravelin3DS.BatchedCollection<Base>.Index
  @usableFromInline
  internal subscript(idx: Ravelin3DS.BatchedCollection<Base>.Index) -> Base.SubSequence {
    get
  }
  @usableFromInline
  internal typealias Element = Base.SubSequence
  @usableFromInline
  internal typealias Indices = Swift.DefaultIndices<Ravelin3DS.BatchedCollection<Base>>
  @usableFromInline
  internal typealias Iterator = Swift.IndexingIterator<Ravelin3DS.BatchedCollection<Base>>
  @usableFromInline
  internal typealias SubSequence = Swift.Slice<Ravelin3DS.BatchedCollection<Base>>
}
extension Swift.Collection {
  @inlinable internal func batched(by size: Swift.Int) -> Ravelin3DS.BatchedCollection<Self> {
    BatchedCollection(base: self, size: size)
  }
}
extension Ravelin3DS.AES {
  convenience public init(key: Swift.String, iv: Swift.String, padding: Ravelin3DS.Padding = .pkcs7) throws
}
public enum JOSESwiftError : Swift.Error {
  case signingFailed(description: Swift.String)
  case verifyingFailed(description: Swift.String)
  case signatureInvalid
  case encryptingFailed(description: Swift.String)
  case decryptingFailed(description: Swift.String)
  case wrongDataEncoding(data: Foundation.Data)
  case invalidCompactSerializationComponentCount(count: Swift.Int)
  case componentNotValidBase64URL(component: Swift.String)
  case componentCouldNotBeInitializedFromData(data: Foundation.Data)
  case couldNotConstructJWK
  case modulusNotBase64URLUIntEncoded
  case exponentNotBase64URLUIntEncoded
  case privateExponentNotBase64URLUIntEncoded
  case symmetricKeyNotBase64URLEncoded
  case xNotBase64URLUIntEncoded
  case yNotBase64URLUIntEncoded
  case privateKeyNotBase64URLUIntEncoded
  case invalidCurveType
  case compressedCurvePointsUnsupported
  case invalidCurvePointOctetLength
  case localAuthenticationFailed(errorCode: Swift.Int)
  case compressionFailed
  case decompressionFailed
  case compressionAlgorithmNotSupported
  case rawDataMustBeGreaterThanZero
  case compressedDataMustBeGreaterThanZero
  case thumbprintSerialization
}
public protocol AEAD {
  static var kLen: Swift.Int { get }
  static var ivRange: Swift.Range<Swift.Int> { get }
}
public class CMAC : Ravelin3DS.Authenticator {
  public enum Error : Swift.Error {
    case wrongKeyLength
    public static func == (a: Ravelin3DS.CMAC.Error, b: Ravelin3DS.CMAC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(key: Swift.Array<Swift.UInt8>) throws
  public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func authenticate(_ bytes: Swift.Array<Swift.UInt8>, cipher: Ravelin3DS.Cipher) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
public enum Bit : Swift.Int {
  case zero
  case one
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension Ravelin3DS.Bit {
  @inlinable internal func inverted() -> Ravelin3DS.Bit {
    self == .zero ? .one : .zero
  }
}
public protocol _UInt8Type {
}
extension Swift.UInt8 : Ravelin3DS._UInt8Type {
}
extension Swift.UInt8 {
  public func bits() -> [Ravelin3DS.Bit]
  public func bits() -> Swift.String
}
public protocol Cryptor {
  mutating func seek(to: Swift.Int) throws
}
@_inheritsConvenienceInitializers @objc(R3DS2UiCustomization) @objcMembers public class R3DS2UiCustomization : ObjectiveC.NSObject, Foundation.NSCopying {
  @objc public func setButtonCustomization(buttonCustomization: Ravelin3DS.R3DS2ButtonCustomization, buttonType: Ravelin3DS.R3DS2ButtonType) throws
  @objc public func setButtonCustomization(buttonCustomization: Ravelin3DS.R3DS2ButtonCustomization, btnType: Swift.String) throws
  @objc public func setToolbarCustomization(toolbarCustomization: Ravelin3DS.R3DS2ToolbarCustomization)
  @objc public func setLabelCustomization(labelCustomization: Ravelin3DS.R3DS2LabelCustomization)
  @objc public func setTextBoxCustomization(textBoxCustomization: Ravelin3DS.R3DS2TextBoxCustomization)
  @objc public func getButtonCustomization(buttonType: Ravelin3DS.R3DS2ButtonType) -> Ravelin3DS.R3DS2ButtonCustomization?
  @objc public func getButtonCustomization(btnType: Swift.String) -> Ravelin3DS.R3DS2ButtonCustomization?
  @objc public func getToolbarCustomization() -> Ravelin3DS.R3DS2ToolbarCustomization?
  @objc public func getLabelCustomization() -> Ravelin3DS.R3DS2LabelCustomization?
  @objc public func getTextboxCustomization() -> Ravelin3DS.R3DS2TextBoxCustomization?
  @objc public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  @objc override dynamic public init()
  @objc deinit
}
public struct ECB : Ravelin3DS.BlockMode {
  public let options: Ravelin3DS.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init()
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping Ravelin3DS.CipherOperationOnBlock, encryptionOperation: @escaping Ravelin3DS.CipherOperationOnBlock) throws -> Ravelin3DS.CipherModeWorker
}
@_inheritsConvenienceInitializers @objc(R3DS2ToolbarCustomization) @objcMembers public class R3DS2ToolbarCustomization : Ravelin3DS.R3DS2Customization {
  @objc public func setBackgroundColor(hexColorCode: Swift.String) throws
  @objc public func setDarkBackgroundColor(hexColorCode: Swift.String) throws
  @objc public func setHeaderText(headerText: Swift.String) throws
  @objc public func setButtonText(buttonText: Swift.String) throws
  @objc public func getBackgroundColor() -> Swift.String
  @objc public func getDarkBackgroundColor() -> Swift.String
  @objc public func getHeaderText() -> Swift.String
  @objc public func getButtonText() -> Swift.String
  @objc override public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  @objc override dynamic public init()
  @objc deinit
}
extension Foundation.Data : Ravelin3DS.ExpressibleAsECPrivateKeyComponents {
  public static func representing(ecPrivateKeyComponents components: Ravelin3DS.ECPrivateKeyComponents) throws -> Foundation.Data
  public func ecPrivateKeyComponents() throws -> Ravelin3DS.ECPrivateKeyComponents
}
public enum PKCS7 {
}
@objc(R3DS2ButtonType) public enum R3DS2ButtonType : Swift.Int, Swift.RawRepresentable, Swift.Equatable, Swift.Hashable, Swift.CaseIterable {
  case SUBMIT
  case CONTINUE
  case NEXT
  case CANCEL
  case RESEND
  public typealias RawValue = Swift.String
  public var rawValue: Ravelin3DS.R3DS2ButtonType.RawValue {
    get
  }
  public init?(rawValue: Ravelin3DS.R3DS2ButtonType.RawValue)
  public typealias AllCases = [Ravelin3DS.R3DS2ButtonType]
  public static var allCases: [Ravelin3DS.R3DS2ButtonType] {
    get
  }
}
extension Ravelin3DS.AES : Ravelin3DS.Cryptors {
  @inlinable final public func makeEncryptor() throws -> Ravelin3DS.Cryptor & Ravelin3DS.Updatable {
    let blockSize = blockMode.customBlockSize ?? AES.blockSize
    let worker = try blockMode.worker(blockSize: blockSize, cipherOperation: encrypt, encryptionOperation: encrypt)
    if worker is StreamModeWorker {
      return try StreamEncryptor(blockSize: blockSize, padding: padding, worker)
    }
    return try BlockEncryptor(blockSize: blockSize, padding: padding, worker)
  }
  @inlinable final public func makeDecryptor() throws -> Ravelin3DS.Cryptor & Ravelin3DS.Updatable {
    let blockSize = blockMode.customBlockSize ?? AES.blockSize
    let cipherOperation: CipherOperationOnBlock = blockMode.options.contains(.useEncryptToDecrypt) == true ? encrypt : decrypt
    let worker = try blockMode.worker(blockSize: blockSize, cipherOperation: cipherOperation, encryptionOperation: encrypt)
    if worker is StreamModeWorker {
      return try StreamDecryptor(blockSize: blockSize, padding: padding, worker)
    }
    return try BlockDecryptor(blockSize: blockSize, padding: padding, worker)
  }
}
extension Ravelin3DS.ECPublicKey : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension Ravelin3DS.ECPublicKey : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension Ravelin3DS.ECPrivateKey : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension Ravelin3DS.ECPrivateKey : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
public enum ECCurveType : Swift.String, Swift.Codable {
  case P256
  case P384
  case P521
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ECCompression : Swift.UInt8 {
  case CompressedYEven
  case CompressedYOdd
  case Uncompressed
  case HybridYEven
  case HybridYOdd
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
final public class MD5 {
  public init()
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension Ravelin3DS.MD5 : Ravelin3DS.Updatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
public struct CBC : Ravelin3DS.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: Ravelin3DS.CBC.Error, b: Ravelin3DS.CBC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: Ravelin3DS.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping Ravelin3DS.CipherOperationOnBlock, encryptionOperation: @escaping Ravelin3DS.CipherOperationOnBlock) throws -> Ravelin3DS.CipherModeWorker
}
public typealias RSAPublicKeyComponents = (modulus: Foundation.Data, exponent: Foundation.Data)
public typealias RSAPrivateKeyComponents = (modulus: Foundation.Data, exponent: Foundation.Data, privateExponent: Foundation.Data)
public protocol ExpressibleAsRSAPublicKeyComponents {
  static func representing(rsaPublicKeyComponents components: Ravelin3DS.RSAPublicKeyComponents) throws -> Self
  func rsaPublicKeyComponents() throws -> Ravelin3DS.RSAPublicKeyComponents
}
public protocol ExpressibleAsRSAPrivateKeyComponents {
  static func representing(rsaPrivateKeyComponents components: Ravelin3DS.RSAPrivateKeyComponents) throws -> Self
  func rsaPrivateKeyComponents() throws -> Ravelin3DS.RSAPrivateKeyComponents
}
public struct RSAPublicKey : Ravelin3DS.JWK {
  public let keyType: Ravelin3DS.JWKKeyType
  public let parameters: [Swift.String : Swift.String]
  public var requiredParameters: [Swift.String : Swift.String] {
    get
  }
  public let modulus: Swift.String
  public let exponent: Swift.String
  public init(modulus: Swift.String, exponent: Swift.String, additionalParameters parameters: [Swift.String : Swift.String] = [:])
  public init(publicKey: Ravelin3DS.ExpressibleAsRSAPublicKeyComponents, additionalParameters parameters: [Swift.String : Swift.String] = [:]) throws
  public init(data: Foundation.Data) throws
  public func converted<T>(to type: T.Type) throws -> T where T : Ravelin3DS.ExpressibleAsRSAPublicKeyComponents
  @available(iOS 11.0, *)
  public func withThumbprintAsKeyId(algorithm: Ravelin3DS.JWKThumbprintAlgorithm = .SHA256) throws -> Ravelin3DS.RSAPublicKey
}
public struct RSAPrivateKey : Ravelin3DS.JWK {
  public let keyType: Ravelin3DS.JWKKeyType
  public let parameters: [Swift.String : Swift.String]
  public var requiredParameters: [Swift.String : Swift.String] {
    get
  }
  public let modulus: Swift.String
  public let exponent: Swift.String
  public let privateExponent: Swift.String
  public init(modulus: Swift.String, exponent: Swift.String, privateExponent: Swift.String, additionalParameters parameters: [Swift.String : Swift.String] = [:])
  public init(privateKey: Ravelin3DS.ExpressibleAsRSAPrivateKeyComponents, additionalParameters parameters: [Swift.String : Swift.String] = [:]) throws
  public init(data: Foundation.Data) throws
  public func converted<T>(to type: T.Type) throws -> T where T : Ravelin3DS.ExpressibleAsRSAPrivateKeyComponents
  @available(iOS 11.0, *)
  public func withThumbprintAsKeyId(algorithm: Ravelin3DS.JWKThumbprintAlgorithm = .SHA256) throws -> Ravelin3DS.RSAPrivateKey
}
public typealias RSAKeyPair = Ravelin3DS.RSAPrivateKey
@_inheritsConvenienceInitializers @objc(R3DS2LabelCustomization) @objcMembers public class R3DS2LabelCustomization : Ravelin3DS.R3DS2Customization {
  @objc public func setHeadingTextColor(hexColorCode: Swift.String) throws
  @objc public func setHeadingDarkTextColor(hexColorCode: Swift.String) throws
  @objc public func setHeadingTextFontName(fontName: Swift.String) throws
  @objc public func setHeadingTextFontSize(fontSize: Swift.Int) throws
  @objc public func getHeadingTextColor() -> Swift.String
  @objc public func getHeadingDarkTextColor() -> Swift.String
  @objc public func getHeadingTextFontName() -> Swift.String
  @objc public func getHeadingTextFontSize() -> Swift.Int
  @objc override public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  @objc override dynamic public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc(R3DS2AuthenticationResponse) @objcMembers public class R3DS2AuthenticationResponse : ObjectiveC.NSObject, Swift.Codable {
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
public struct Signer<KeyType> {
  public init?(signingAlgorithm: Ravelin3DS.SignatureAlgorithm, key: KeyType)
}
extension Ravelin3DS.Signer {
  @available(*, deprecated, message: "Use `init?(signingAlgorithm: SignatureAlgorithm, key: KeyType)` instead")
  public init?(signingAlgorithm: Ravelin3DS.SignatureAlgorithm, privateKey: KeyType)
}
extension Ravelin3DS.PKCS5 {
  public struct PBKDF1 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: Ravelin3DS.PKCS5.PBKDF1.Error, b: Ravelin3DS.PKCS5.PBKDF1.Error) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum Variant {
      case md5, sha1
      @usableFromInline
      internal var size: Swift.Int {
        get
      }
      @usableFromInline
      internal func calculateHash(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
      public static func == (a: Ravelin3DS.PKCS5.PBKDF1.Variant, b: Ravelin3DS.PKCS5.PBKDF1.Variant) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    @usableFromInline
    internal let iterations: Swift.Int
    @usableFromInline
    internal let variant: Ravelin3DS.PKCS5.PBKDF1.Variant
    @usableFromInline
    internal let keyLength: Swift.Int
    @usableFromInline
    internal let t1: Swift.Array<Swift.UInt8>
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, variant: Ravelin3DS.PKCS5.PBKDF1.Variant = .sha1, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil) throws
    @inlinable public func calculate() -> Swift.Array<Swift.UInt8> {
      var t = self.t1
      for _ in 2...self.iterations {
        t = self.variant.calculateHash(t)
      }
      return Array(t[0..<self.keyLength])
    }
  }
}
extension Ravelin3DS.Blowfish {
  convenience public init(key: Swift.String, iv: Swift.String, padding: Ravelin3DS.Padding = .pkcs7) throws
}
public protocol CompactDeserializable {
  static var componentCount: Swift.Int { get }
  init(from deserializer: Ravelin3DS.CompactDeserializer) throws
}
public protocol CompactDeserializer {
  func deserialize<T>(_ type: T.Type, at index: Swift.Int) throws -> T where T : Ravelin3DS.DataConvertible
}
public struct JOSEDeserializer {
  public init()
  public func deserialize<T>(_ type: T.Type, fromCompactSerialization compactSerialization: Swift.String) throws -> T where T : Ravelin3DS.CompactDeserializable
}
public enum ComponentCompactSerializedIndex {
}
public protocol CommonHeaderParameterSpace {
  var jku: Foundation.URL? { get set }
  var jwk: Swift.String? { get set }
  var jwkTyped: Ravelin3DS.JWK? { get set }
  var kid: Swift.String? { get set }
  var x5u: Foundation.URL? { get set }
  var x5c: [Swift.String]? { get set }
  var x5t: Swift.String? { get set }
  var x5tS256: Swift.String? { get set }
  var typ: Swift.String? { get set }
  var cty: Swift.String? { get set }
  var crit: [Swift.String]? { get set }
}
public struct Verifier {
  public init?<KeyType>(verifyingAlgorithm: Ravelin3DS.SignatureAlgorithm, key: KeyType)
}
extension Ravelin3DS.Verifier {
  @available(*, deprecated, message: "Use `init?(verifyingAlgorithm: SignatureAlgorithm, key: KeyType)` instead")
  public init?<KeyType>(verifyingAlgorithm: Ravelin3DS.SignatureAlgorithm, publicKey: KeyType)
}
public enum JWKKeyType : Swift.String, Swift.Codable {
  case RSA
  case OCT
  case EC
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol JWK : Swift.Decodable, Swift.Encodable {
  var keyType: Ravelin3DS.JWKKeyType { get }
  var parameters: [Swift.String : Swift.String] { get }
  var requiredParameters: [Swift.String : Swift.String] { get }
  subscript(parameter: Swift.String) -> Swift.String? { get }
  init(data: Foundation.Data) throws
  func jsonString() -> Swift.String?
  func jsonData() -> Foundation.Data?
  @available(iOS 11.0, *)
  func thumbprint(algorithm: Ravelin3DS.JWKThumbprintAlgorithm) throws -> Swift.String
  @available(iOS 11.0, *)
  func withThumbprintAsKeyId(algorithm: Ravelin3DS.JWKThumbprintAlgorithm) throws -> Self
}
extension Ravelin3DS.JWK {
  @available(iOS 11.0, *)
  public func thumbprint(algorithm: Ravelin3DS.JWKThumbprintAlgorithm = .SHA256) throws -> Swift.String
}
final public class Poly1305 : Ravelin3DS.Authenticator {
  public enum Error : Swift.Error {
    case authenticateError
    public static func == (a: Ravelin3DS.Poly1305.Error, b: Ravelin3DS.Poly1305.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension Swift.String {
  public func decryptBase64ToString(cipher: Ravelin3DS.Cipher) throws -> Swift.String
  public func decryptBase64(cipher: Ravelin3DS.Cipher) throws -> Swift.Array<Swift.UInt8>
}
public protocol Updatable {
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8>
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws
}
extension Ravelin3DS.Updatable {
  @inlinable public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    let processed = try update(withBytes: bytes, isLast: isLast)
    if !processed.isEmpty {
      output(processed)
    }
  }
  @inlinable public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes, isLast: isLast)
  }
  @inlinable public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes.slice, isLast: isLast)
  }
  @inlinable public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.update(withBytes: bytes.slice, isLast: isLast, output: output)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes, isLast: true)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    try self.finish(withBytes: bytes.slice)
  }
  @inlinable public mutating func finish() throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: [], isLast: true)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    let processed = try update(withBytes: bytes, isLast: true)
    if !processed.isEmpty {
      output(processed)
    }
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.finish(withBytes: bytes.slice, output: output)
  }
  @inlinable public mutating func finish(output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.finish(withBytes: [], output: output)
  }
}
final public class GCM : Ravelin3DS.BlockMode {
  public enum Mode {
    case combined
    case detached
    public static func == (a: Ravelin3DS.GCM.Mode, b: Ravelin3DS.GCM.Mode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let options: Ravelin3DS.BlockModeOption
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case fail
    public static func == (a: Ravelin3DS.GCM.Error, b: Ravelin3DS.GCM.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let customBlockSize: Swift.Int?
  final public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, tagLength: Swift.Int = 16, mode: Ravelin3DS.GCM.Mode = .detached)
  convenience public init(iv: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, mode: Ravelin3DS.GCM.Mode = .detached)
  final public func worker(blockSize: Swift.Int, cipherOperation: @escaping Ravelin3DS.CipherOperationOnBlock, encryptionOperation: @escaping Ravelin3DS.CipherOperationOnBlock) throws -> Ravelin3DS.CipherModeWorker
  @objc deinit
}
extension Ravelin3DS.JWKSet : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension Ravelin3DS.JWKSet : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension Security.SecKey : Ravelin3DS.ExpressibleAsRSAPublicKeyComponents {
  public static func representing(rsaPublicKeyComponents components: Ravelin3DS.RSAPublicKeyComponents) throws -> Self
  public func rsaPublicKeyComponents() throws -> Ravelin3DS.RSAPublicKeyComponents
}
public struct JWSHeader {
  public init(algorithm: Ravelin3DS.SignatureAlgorithm)
  public init(parameters: [Swift.String : Any]) throws
}
extension Ravelin3DS.JWSHeader {
  public var algorithm: Ravelin3DS.SignatureAlgorithm? {
    get
  }
}
extension Ravelin3DS.JWSHeader : Ravelin3DS.CommonHeaderParameterSpace {
  public var jku: Foundation.URL? {
    get
    set
  }
  public var jwk: Swift.String? {
    get
    set
  }
  public var jwkTyped: Ravelin3DS.JWK? {
    get
    set
  }
  public var kid: Swift.String? {
    get
    set
  }
  public var x5u: Foundation.URL? {
    get
    set
  }
  public var x5c: [Swift.String]? {
    get
    set
  }
  public var x5t: Swift.String? {
    get
    set
  }
  public var x5tS256: Swift.String? {
    get
    set
  }
  public var typ: Swift.String? {
    get
    set
  }
  public var cty: Swift.String? {
    get
    set
  }
  public var crit: [Swift.String]? {
    get
    set
  }
}
public struct JWE {
  public let header: Ravelin3DS.JWEHeader
  public let encryptedKey: Foundation.Data
  public let initializationVector: Foundation.Data
  public let ciphertext: Foundation.Data
  public let authenticationTag: Foundation.Data
  public var compactSerializedString: Swift.String {
    get
  }
  public var compactSerializedData: Foundation.Data {
    get
  }
  public init<KeyType>(header: Ravelin3DS.JWEHeader, payload: Ravelin3DS.Payload, encrypter: Ravelin3DS.Encrypter<KeyType>) throws
  public init(compactSerialization: Swift.String) throws
  public init(compactSerialization: Foundation.Data) throws
  @available(*, deprecated, message: "Use `decrypt(using decrypter:)` instead")
  public func decrypt<KeyType>(with key: KeyType) throws -> Ravelin3DS.Payload
  public func decrypt(using decrypter: Ravelin3DS.Decrypter) throws -> Ravelin3DS.Payload
}
extension Ravelin3DS.JWE : Ravelin3DS.CompactSerializable {
  public func serialize(to serializer: inout Ravelin3DS.CompactSerializer)
}
extension Ravelin3DS.JWE : Ravelin3DS.CompactDeserializable {
  public static var componentCount: Swift.Int {
    get
  }
  public init(from deserializer: Ravelin3DS.CompactDeserializer) throws
}
final public class HMAC : Ravelin3DS.Authenticator {
  public enum Error : Swift.Error {
    case authenticateError
    case invalidInput
    public static func == (a: Ravelin3DS.HMAC.Error, b: Ravelin3DS.HMAC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Variant {
    case sha1, sha256, sha384, sha512, md5
    public static func == (a: Ravelin3DS.HMAC.Variant, b: Ravelin3DS.HMAC.Variant) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(key: Swift.Array<Swift.UInt8>, variant: Ravelin3DS.HMAC.Variant = .md5)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension Security.SecKey : Ravelin3DS.ExpressibleAsECPrivateKeyComponents {
  public static func representing(ecPrivateKeyComponents components: Ravelin3DS.ECPrivateKeyComponents) throws -> Self
  public func ecPrivateKeyComponents() throws -> Ravelin3DS.ECPrivateKeyComponents
}
public struct HKDF {
  public enum Error : Swift.Error {
    case invalidInput
    case derivedKeyTooLong
    public static func == (a: Ravelin3DS.HKDF.Error, b: Ravelin3DS.HKDF.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>? = nil, info: Swift.Array<Swift.UInt8>? = nil, keyLength: Swift.Int? = nil, variant: Ravelin3DS.HMAC.Variant = .sha256) throws
  public func calculate() throws -> Swift.Array<Swift.UInt8>
}
final public class SHA1 {
  @usableFromInline
  internal static let digestLength: Swift.Int
  @usableFromInline
  internal static let blockSize: Swift.Int
  @usableFromInline
  internal static let hashInitialValue: Swift.ContiguousArray<Swift.UInt32>
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var processedBytesTotalCount: Swift.Int
  @usableFromInline
  final internal var accumulatedHash: Swift.ContiguousArray<Swift.UInt32>
  public init()
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  @usableFromInline
  final internal func process(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.ContiguousArray<Swift.UInt32>)
  @objc deinit
}
extension Ravelin3DS.SHA1 : Ravelin3DS.Updatable {
  @discardableResult
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      let lengthInBits = (processedBytesTotalCount + self.accumulated.count) * 8
      let lengthBytes = lengthInBits.bytes(totalBytes: 64 / 8) // A 64-bit representation of b

      // Step 1. Append padding
      bitPadding(to: &self.accumulated, blockSize: SHA1.blockSize, allowance: 64 / 8)

      // Step 2. Append Length a 64-bit representation of lengthInBits
      self.accumulated += lengthBytes
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: SHA1.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= SHA1.blockSize {
        self.process(block: chunk, currentHash: &self.accumulatedHash)
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)
    self.processedBytesTotalCount += processedBytes

    // output current hash
    var result = Array<UInt8>(repeating: 0, count: SHA1.digestLength)
    var pos = 0
    for idx in 0..<self.accumulatedHash.count {
      let h = self.accumulatedHash[idx]
      result[pos + 0] = UInt8((h >> 24) & 0xff)
      result[pos + 1] = UInt8((h >> 16) & 0xff)
      result[pos + 2] = UInt8((h >> 8) & 0xff)
      result[pos + 3] = UInt8(h & 0xff)
      pos += 4
    }

    // reset hash value for instance
    if isLast {
      self.accumulatedHash = SHA1.hashInitialValue
    }

    return result
  }
}
@objc(R3DS2Transaction) public protocol R3DS2Transaction {
  @objc func getAuthenticationRequestParameters() throws -> Ravelin3DS.R3DS2AuthenticationRequestParameters
  @objc func doChallenge(challengeParameters: Ravelin3DS.R3DS2ChallengeParameters, challengeStatusReceiver: Ravelin3DS.R3DS2ChallengeStatusReceiver, timeOut: Swift.Int, challengeView: Ravelin3DS.R3DS2ChallengeView) throws
  @objc func getProgressView() throws -> Ravelin3DS.R3DS2ProgressDialog
  @objc func close() throws
}
final public class Checksum {
  @usableFromInline
  internal static let table32: [Swift.UInt32]
  @usableFromInline
  internal static let table32c: [Swift.UInt32]
  @usableFromInline
  internal static let table16: [Swift.UInt16]
  @usableFromInline
  internal init()
  @inlinable final internal func crc32(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    var crc: UInt32 = seed != nil ? seed! : 0xFFFF_FFFF
    for chunk in message.batched(by: 256) {
      for b in chunk {
        let idx = Int((crc ^ UInt32(reflect ? b : reversed(b))) & 0xFF)
        crc = (crc >> 8) ^ Checksum.table32[idx]
      }
    }
    return (reflect ? crc : reversed(crc)) ^ 0xFFFF_FFFF
  }
  @inlinable final internal func crc32c(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    var crc: UInt32 = seed != nil ? seed! : 0xFFFF_FFFF
    for chunk in message.batched(by: 256) {
      for b in chunk {
        let idx = Int((crc ^ UInt32(reflect ? b : reversed(b))) & 0xFF)
        crc = (crc >> 8) ^ Checksum.table32c[idx]
      }
    }
    return (reflect ? crc : reversed(crc)) ^ 0xFFFF_FFFF
  }
  @inlinable final internal func crc16(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt16? = nil) -> Swift.UInt16 {
    var crc: UInt16 = seed != nil ? seed! : 0x0000
    for chunk in message.batched(by: 256) {
      for b in chunk {
        crc = (crc >> 8) ^ Checksum.table16[Int((crc ^ UInt16(b)) & 0xFF)]
      }
    }
    return crc
  }
  @objc deinit
}
extension Ravelin3DS.Checksum {
  @inlinable public static func crc32(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    Checksum().crc32(message, seed: seed, reflect: reflect)
  }
  @inlinable public static func crc32c(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    Checksum().crc32c(message, seed: seed, reflect: reflect)
  }
  @inlinable public static func crc16(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt16? = nil) -> Swift.UInt16 {
    Checksum().crc16(message, seed: seed)
  }
}
extension Swift.String {
  @inlinable public var bytes: Swift.Array<Swift.UInt8> {
    get {
    data(using: String.Encoding.utf8, allowLossyConversion: true)?.bytes ?? Array(utf8)
  }
  }
  @inlinable public func md5() -> Swift.String {
    self.bytes.md5().toHexString()
  }
  @inlinable public func sha1() -> Swift.String {
    self.bytes.sha1().toHexString()
  }
  @inlinable public func sha224() -> Swift.String {
    self.bytes.sha224().toHexString()
  }
  @inlinable public func sha256() -> Swift.String {
    self.bytes.sha256().toHexString()
  }
  @inlinable public func sha384() -> Swift.String {
    self.bytes.sha384().toHexString()
  }
  @inlinable public func sha512() -> Swift.String {
    self.bytes.sha512().toHexString()
  }
  @inlinable public func sha3(_ variant: Ravelin3DS.SHA3.Variant) -> Swift.String {
    self.bytes.sha3(variant).toHexString()
  }
  @inlinable public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String {
    self.bytes.crc32(seed: seed, reflect: reflect).bytes().toHexString()
  }
  @inlinable public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String {
    self.bytes.crc32c(seed: seed, reflect: reflect).bytes().toHexString()
  }
  @inlinable public func crc16(seed: Swift.UInt16? = nil) -> Swift.String {
    self.bytes.crc16(seed: seed).bytes().toHexString()
  }
  @inlinable public func encrypt(cipher: Ravelin3DS.Cipher) throws -> Swift.String {
    try self.bytes.encrypt(cipher: cipher).toHexString()
  }
  @inlinable public func encryptToBase64(cipher: Ravelin3DS.Cipher) throws -> Swift.String {
    try self.bytes.encrypt(cipher: cipher).toBase64()
  }
  @inlinable public func authenticate<A>(with authenticator: A) throws -> Swift.String where A : Ravelin3DS.Authenticator {
    try self.bytes.authenticate(with: authenticator).toHexString()
  }
}
@inlinable internal func rotateLeft(_ value: Swift.UInt8, by: Swift.UInt8) -> Swift.UInt8 {
  ((value << by) & 0xff) | (value >> (8 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt16, by: Swift.UInt16) -> Swift.UInt16 {
  ((value << by) & 0xffff) | (value >> (16 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt32, by: Swift.UInt32) -> Swift.UInt32 {
  ((value << by) & 0xffffffff) | (value >> (32 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt64, by: Swift.UInt64) -> Swift.UInt64 {
  (value << by) | (value >> (64 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt16, by: Swift.UInt16) -> Swift.UInt16 {
  (value >> by) | (value << (16 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt32, by: Swift.UInt32) -> Swift.UInt32 {
  (value >> by) | (value << (32 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt64, by: Swift.UInt64) -> Swift.UInt64 {
  ((value >> by) | (value << (64 - by)))
}
@inlinable internal func reversed(_ uint8: Swift.UInt8) -> Swift.UInt8 {
  var v = uint8
  v = (v & 0xf0) >> 4 | (v & 0x0f) << 4
  v = (v & 0xcc) >> 2 | (v & 0x33) << 2
  v = (v & 0xaa) >> 1 | (v & 0x55) << 1
  return v
}
@inlinable internal func reversed(_ uint32: Swift.UInt32) -> Swift.UInt32 {
  var v = uint32
  v = ((v >> 1) & 0x55555555) | ((v & 0x55555555) << 1)
  v = ((v >> 2) & 0x33333333) | ((v & 0x33333333) << 2)
  v = ((v >> 4) & 0x0f0f0f0f) | ((v & 0x0f0f0f0f) << 4)
  v = ((v >> 8) & 0x00ff00ff) | ((v & 0x00ff00ff) << 8)
  v = ((v >> 16) & 0xffff) | ((v & 0xffff) << 16)
  return v
}
@inlinable internal func xor<T, V>(_ left: T, _ right: V) -> Swift.ArraySlice<Swift.UInt8> where T : Swift.RandomAccessCollection, V : Swift.RandomAccessCollection, T.Element == Swift.UInt8, T.Index == Swift.Int, V.Element == Swift.UInt8, V.Index == Swift.Int {
  return xor(left, right).slice
}
@inlinable internal func xor<T, V>(_ left: T, _ right: V) -> Swift.Array<Swift.UInt8> where T : Swift.RandomAccessCollection, V : Swift.RandomAccessCollection, T.Element == Swift.UInt8, T.Index == Swift.Int, V.Element == Swift.UInt8, V.Index == Swift.Int {
  let length = Swift.min(left.count, right.count)

  let buf = UnsafeMutablePointer<UInt8>.allocate(capacity: length)
  buf.initialize(repeating: 0, count: length)
  defer {
    buf.deinitialize(count: length)
    buf.deallocate()
  }

  // xor
  for i in 0..<length {
    buf[i] = left[left.startIndex.advanced(by: i)] ^ right[right.startIndex.advanced(by: i)]
  }

  return Array(UnsafeBufferPointer(start: buf, count: length))
}
@inline(__always) @inlinable internal func bitPadding(to data: inout Swift.Array<Swift.UInt8>, blockSize: Swift.Int, allowance: Swift.Int = 0) {
  let msgLength = data.count
  // Step 1. Append Padding Bits
  // append one bit (UInt8 with one bit) to message
  data.append(0x80)

  // Step 2. append "0" bit until message length in bits  448 (mod 512)
  let max = blockSize - allowance // 448, 986
  if msgLength % blockSize < max { // 448
    data += Array<UInt8>(repeating: 0, count: max - 1 - (msgLength % blockSize))
  } else {
    data += Array<UInt8>(repeating: 0, count: blockSize + max - 1 - (msgLength % blockSize))
  }
}
extension Swift.Collection where Self.Element == Swift.UInt8, Self.Index == Swift.Int {
  @inlinable internal func toUInt32Array() -> Swift.Array<Swift.UInt32> {
    guard !isEmpty else {
      return []
    }

    let c = strideCount(from: startIndex, to: endIndex, by: 4)
    return Array<UInt32>(unsafeUninitializedCapacity: c) { buf, count in
      var counter = 0
      for idx in stride(from: startIndex, to: endIndex, by: 4) {
        let val = UInt32(bytes: self, fromIndex: idx).bigEndian
        buf[counter] = val
        counter += 1
      }
      count = counter
      assert(counter == c)
    }
  }
  @inlinable internal func toUInt64Array() -> Swift.Array<Swift.UInt64> {
    guard !isEmpty else {
      return []
    }

    let c = strideCount(from: startIndex, to: endIndex, by: 8)
    return Array<UInt64>(unsafeUninitializedCapacity: c) { buf, count in
      var counter = 0
      for idx in stride(from: startIndex, to: endIndex, by: 8) {
        let val = UInt64(bytes: self, fromIndex: idx).bigEndian
        buf[counter] = val
        counter += 1
      }
      count = counter
      assert(counter == c)
    }
  }
}
@usableFromInline
internal func strideCount(from: Swift.Int, to: Swift.Int, by: Swift.Int) -> Swift.Int
extension Foundation.Data : Ravelin3DS.ExpressibleAsECPublicKeyComponents {
  public static func representing(ecPublicKeyComponents components: Ravelin3DS.ECPublicKeyComponents) throws -> Foundation.Data
  public func ecPublicKeyComponents() throws -> Ravelin3DS.ECPublicKeyComponents
}
public struct CCM {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case invalidParameter
    case fail
    public static func == (a: Ravelin3DS.CCM.Error, b: Ravelin3DS.CCM.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: Ravelin3DS.BlockModeOption
  public let customBlockSize: Swift.Int?
  public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping Ravelin3DS.CipherOperationOnBlock, encryptionOperation: @escaping Ravelin3DS.CipherOperationOnBlock) throws -> Ravelin3DS.CipherModeWorker
}
@objc(R3DS2Severity) public enum R3DS2Severity : Swift.Int, Swift.RawRepresentable, Swift.Equatable, Swift.Hashable, Swift.CaseIterable {
  case LOW
  case MEDIUM
  case HIGH
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [Ravelin3DS.R3DS2Severity]
  public typealias RawValue = Swift.Int
  public static var allCases: [Ravelin3DS.R3DS2Severity] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
@usableFromInline
final internal class StreamEncryptor : Ravelin3DS.Cryptor, Ravelin3DS.Updatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal var worker: Ravelin3DS.CipherModeWorker
  @usableFromInline
  final internal let padding: Ravelin3DS.Padding
  @usableFromInline
  final internal var lastBlockRemainder: Swift.Int
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: Ravelin3DS.Padding, _ worker: Ravelin3DS.CipherModeWorker) throws
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8> {
    var accumulated = Array(bytes)
    if isLast {
      // CTR doesn't need padding. Really. Add padding to the last block if really want. but... don't.
      accumulated = self.padding.add(to: accumulated, blockSize: self.blockSize - self.lastBlockRemainder)
    }

    var encrypted = Array<UInt8>(reserveCapacity: bytes.count)
    for chunk in accumulated.batched(by: self.blockSize) {
      encrypted += self.worker.encrypt(block: chunk)
    }

    // omit unecessary calculation if not needed
    if self.padding != .noPadding {
      self.lastBlockRemainder = encrypted.count.quotientAndRemainder(dividingBy: self.blockSize).remainder
    }

    if var finalizingWorker = worker as? FinalizingEncryptModeWorker, isLast == true {
      encrypted = Array(try finalizingWorker.finalize(encrypt: encrypted.slice))
    }

    return encrypted
  }
  @usableFromInline
  final internal func seek(to: Swift.Int) throws
  @objc @usableFromInline
  deinit
}
public enum PKCS5 {
}
public class BlockDecryptor : Ravelin3DS.Cryptor, Ravelin3DS.Updatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal let padding: Ravelin3DS.Padding
  @usableFromInline
  internal var worker: Ravelin3DS.CipherModeWorker
  @usableFromInline
  internal var accumulated: [Swift.UInt8]
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: Ravelin3DS.Padding, _ worker: Ravelin3DS.CipherModeWorker) throws
  @inlinable public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    // If a worker (eg GCM) can combine ciphertext + tag
    // we need to remove tag from the ciphertext.
    if !isLast && self.accumulated.count < self.blockSize + self.worker.additionalBufferSize {
      return []
    }

    let accumulatedWithoutSuffix: Array<UInt8>
    if self.worker.additionalBufferSize > 0 {
      // FIXME: how slow is that?
      accumulatedWithoutSuffix = Array(self.accumulated.prefix(self.accumulated.count - self.worker.additionalBufferSize))
    } else {
      accumulatedWithoutSuffix = self.accumulated
    }

    var processedBytesCount = 0
    var plaintext = Array<UInt8>(reserveCapacity: accumulatedWithoutSuffix.count)
    // Processing in a block-size manner. It's good for block modes, but bad for stream modes.
    for var chunk in accumulatedWithoutSuffix.batched(by: self.blockSize) {
      if isLast || (accumulatedWithoutSuffix.count - processedBytesCount) >= blockSize {
        let isLastChunk = processedBytesCount + chunk.count == accumulatedWithoutSuffix.count

        if isLast, isLastChunk, var finalizingWorker = worker as? FinalizingDecryptModeWorker {
          chunk = try finalizingWorker.willDecryptLast(bytes: chunk + accumulated.suffix(worker.additionalBufferSize)) // tag size
        }

        if !chunk.isEmpty {
          plaintext += worker.decrypt(block: chunk)
        }

        if isLast, isLastChunk, var finalizingWorker = worker as? FinalizingDecryptModeWorker {
          plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
        }

        processedBytesCount += chunk.count
      }
    }
    accumulated.removeFirst(processedBytesCount) // super-slow

    if isLast {
      if accumulatedWithoutSuffix.isEmpty, var finalizingWorker = worker as? FinalizingDecryptModeWorker {
        try finalizingWorker.willDecryptLast(bytes: self.accumulated.suffix(self.worker.additionalBufferSize))
        plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
      }
      plaintext = self.padding.remove(from: plaintext, blockSize: self.blockSize)
    }

    return plaintext
  }
  public func seek(to position: Swift.Int) throws
  @objc deinit
}
public protocol CipherModeWorker {
  var cipherOperation: Ravelin3DS.CipherOperationOnBlock { get }
  var additionalBufferSize: Swift.Int { get }
  @inlinable mutating func encrypt(block plaintext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @inlinable mutating func decrypt(block ciphertext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
}
public protocol BlockModeWorker : Ravelin3DS.CipherModeWorker {
  var blockSize: Swift.Int { get }
}
public protocol CounterModeWorker : Ravelin3DS.CipherModeWorker {
  associatedtype Counter
  var counter: Self.Counter { get set }
}
public protocol SeekableModeWorker : Ravelin3DS.CipherModeWorker {
  mutating func seek(to position: Swift.Int) throws
}
public protocol StreamModeWorker : Ravelin3DS.CipherModeWorker {
}
public protocol FinalizingEncryptModeWorker : Ravelin3DS.CipherModeWorker {
  mutating func finalize(encrypt ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
public protocol FinalizingDecryptModeWorker : Ravelin3DS.CipherModeWorker {
  @discardableResult
  mutating func willDecryptLast(bytes ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func didDecryptLast(bytes plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func finalize(decrypt plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
@_inheritsConvenienceInitializers @objc(R3DS2Error) @objcMembers public class R3DS2Error : ObjectiveC.NSObject {
  @objc public static func InvalidInput(message: Swift.String, cause: Swift.Error?) -> Swift.Error
  @objc public static func SDKAlreadyInitialized(message: Swift.String, cause: Swift.Error?) -> Swift.Error
  @objc public static func SDKNotInitialized(message: Swift.String, cause: Swift.Error?) -> Swift.Error
  @objc public static func SDKRuntime(message: Swift.String, errorCode: Swift.String?, cause: Swift.Error?) -> Swift.Error
  @objc override dynamic public init()
  @objc deinit
}
public enum RAV3DS2ErrorCode : Swift.String, Swift.Equatable, Swift.Hashable, Swift.RawRepresentable {
  case transactionIsAlreadyClosed
  case challengeAlreadyInProgress
  case transactioRAVnnotBeClosedChallengeInProdgress
  case errorCreatingTransaction
  case progresViewInitializationFailed
  case noLogoImageForGivenDirectoryServerID
  case missingConfigurationForScheme
  case licenseKeyMissing
  case licenseFormatInvalid
  case licenseExpired
  case licenseSignatureInvalid
  case licenseInvalid
  case errorGettingSDKVersion
  case challengeError
  case challengeProcessingFailed
  case failedToHandleChallengeResponse
  case failedToSendChallengeRequest
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
final public class Rabbit {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    public static func == (a: Ravelin3DS.Rabbit.Error, b: Ravelin3DS.Rabbit.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let ivSize: Swift.Int
  public static let keySize: Swift.Int
  public static let blockSize: Swift.Int
  final public var keySize: Swift.Int {
    get
  }
  convenience public init(key: Swift.Array<Swift.UInt8>) throws
  public init(key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>?) throws
  @objc deinit
}
extension Ravelin3DS.Rabbit : Ravelin3DS.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
public struct PCBC : Ravelin3DS.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: Ravelin3DS.PCBC.Error, b: Ravelin3DS.PCBC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: Ravelin3DS.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping Ravelin3DS.CipherOperationOnBlock, encryptionOperation: @escaping Ravelin3DS.CipherOperationOnBlock) throws -> Ravelin3DS.CipherModeWorker
}
public protocol Authenticator {
  func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
final public class ChaCha20 {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    case notSupported
    public static func == (a: Ravelin3DS.ChaCha20.Error, b: Ravelin3DS.ChaCha20.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, iv nonce: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
extension Ravelin3DS.ChaCha20 : Ravelin3DS.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension Ravelin3DS.ChaCha20 {
  public struct ChaChaEncryptor : Ravelin3DS.Cryptor, Ravelin3DS.Updatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension Ravelin3DS.ChaCha20 {
  public struct ChaChaDecryptor : Ravelin3DS.Cryptor, Ravelin3DS.Updatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = true) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension Ravelin3DS.ChaCha20 : Ravelin3DS.Cryptors {
  final public func makeEncryptor() -> Ravelin3DS.Cryptor & Ravelin3DS.Updatable
  final public func makeDecryptor() -> Ravelin3DS.Cryptor & Ravelin3DS.Updatable
}
public typealias CipherOperationOnBlock = (_ block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>?
public protocol BlockMode {
  var options: Ravelin3DS.BlockModeOption { get }
  @inlinable func worker(blockSize: Swift.Int, cipherOperation: @escaping Ravelin3DS.CipherOperationOnBlock, encryptionOperation: @escaping Ravelin3DS.CipherOperationOnBlock) throws -> Ravelin3DS.CipherModeWorker
  var customBlockSize: Swift.Int? { get }
}
extension Swift.Array {
  @inlinable internal init(reserveCapacity: Swift.Int) {
    self = Array<Element>()
    self.reserveCapacity(reserveCapacity)
  }
  @inlinable internal var slice: Swift.ArraySlice<Element> {
    get {
    self[self.startIndex ..< self.endIndex]
  }
  }
}
extension Swift.Array where Element == Swift.UInt8 {
  public init(hex: Swift.String)
  public func toHexString() -> Swift.String
}
extension Swift.Array where Element == Swift.UInt8 {
  @available(*, deprecated)
  public func chunks(size chunksize: Swift.Int) -> Swift.Array<Swift.Array<Element>>
  public func md5() -> [Element]
  public func sha1() -> [Element]
  public func sha224() -> [Element]
  public func sha256() -> [Element]
  public func sha384() -> [Element]
  public func sha512() -> [Element]
  public func sha2(_ variant: Ravelin3DS.SHA2.Variant) -> [Element]
  public func sha3(_ variant: Ravelin3DS.SHA3.Variant) -> [Element]
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc16(seed: Swift.UInt16? = nil) -> Swift.UInt16
  public func encrypt(cipher: Ravelin3DS.Cipher) throws -> [Element]
  public func decrypt(cipher: Ravelin3DS.Cipher) throws -> [Element]
  public func authenticate<A>(with authenticator: A) throws -> [Element] where A : Ravelin3DS.Authenticator
}
@_inheritsConvenienceInitializers @objc(R3DS2ChallengeParameters) @objcMembers public class R3DS2ChallengeParameters : ObjectiveC.NSObject {
  @objc convenience public init(authenticationResponse authResponse: Ravelin3DS.R3DS2AuthenticationResponse?)
  @objc public func set3DSServerTransactionID(_ threeDSServerTransactionID: Swift.String)
  @objc public func setAcsTransactionID(_ acsTransactionID: Swift.String)
  @objc public func setAcsRefNumber(_ acsReferenceNumber: Swift.String)
  @objc public func setAcsSignedContent(_ acsSignedContent: Swift.String)
  @objc public func setThreeDSRequestorAppURL(_ threeDSRequestorAppURL: Swift.String)
  @objc public func get3DSServerTransactionID() -> Swift.String
  @objc public func getAcsTransactionID() -> Swift.String
  @objc public func getAcsRefNumber() -> Swift.String
  @objc public func getAcsSignedContent() -> Swift.String
  @objc public func getThreeDSRequestorAppURL() -> Swift.String
  @objc override dynamic public init()
  @objc deinit
}
public protocol DataConvertible {
  init?(_ data: Foundation.Data)
  func data() -> Foundation.Data
}
public protocol PaddingProtocol {
  func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
}
public enum Padding : Ravelin3DS.PaddingProtocol {
  case noPadding, zeroPadding, pkcs7, pkcs5, iso78164, iso10126
  public func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  public func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
  public static func == (a: Ravelin3DS.Padding, b: Ravelin3DS.Padding) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public typealias ECPublicKeyComponents = (crv: Swift.String, x: Foundation.Data, y: Foundation.Data)
public typealias ECPrivateKeyComponents = (crv: Swift.String, x: Foundation.Data, y: Foundation.Data, d: Foundation.Data)
public protocol ExpressibleAsECPublicKeyComponents {
  static func representing(ecPublicKeyComponents components: Ravelin3DS.ECPublicKeyComponents) throws -> Self
  func ecPublicKeyComponents() throws -> Ravelin3DS.ECPublicKeyComponents
}
public protocol ExpressibleAsECPrivateKeyComponents {
  static func representing(ecPrivateKeyComponents components: Ravelin3DS.ECPrivateKeyComponents) throws -> Self
  func ecPrivateKeyComponents() throws -> Ravelin3DS.ECPrivateKeyComponents
}
public struct ECPublicKey : Ravelin3DS.JWK {
  public let keyType: Ravelin3DS.JWKKeyType
  public let parameters: [Swift.String : Swift.String]
  public var requiredParameters: [Swift.String : Swift.String] {
    get
  }
  public let crv: Ravelin3DS.ECCurveType
  public let x: Swift.String
  public let y: Swift.String
  public init(crv: Ravelin3DS.ECCurveType, x: Swift.String, y: Swift.String, additionalParameters parameters: [Swift.String : Swift.String] = [:])
  public init(publicKey: Ravelin3DS.ExpressibleAsECPublicKeyComponents, additionalParameters parameters: [Swift.String : Swift.String] = [:]) throws
  public init(data: Foundation.Data) throws
  public func converted<T>(to type: T.Type) throws -> T where T : Ravelin3DS.ExpressibleAsECPublicKeyComponents
  @available(iOS 11.0, *)
  public func withThumbprintAsKeyId(algorithm: Ravelin3DS.JWKThumbprintAlgorithm = .SHA256) throws -> Ravelin3DS.ECPublicKey
}
public struct ECPrivateKey : Ravelin3DS.JWK {
  public let keyType: Ravelin3DS.JWKKeyType
  public let parameters: [Swift.String : Swift.String]
  public var requiredParameters: [Swift.String : Swift.String] {
    get
  }
  public let crv: Ravelin3DS.ECCurveType
  public let x: Swift.String
  public let y: Swift.String
  public let privateKey: Swift.String
  public init(crv: Swift.String, x: Swift.String, y: Swift.String, privateKey: Swift.String, additionalParameters parameters: [Swift.String : Swift.String] = [:]) throws
  public init(privateKey: Ravelin3DS.ExpressibleAsECPrivateKeyComponents, additionalParameters parameters: [Swift.String : Swift.String] = [:]) throws
  public init(data: Foundation.Data) throws
  public func converted<T>(to type: T.Type) throws -> T where T : Ravelin3DS.ExpressibleAsECPrivateKeyComponents
  @available(iOS 11.0, *)
  public func withThumbprintAsKeyId(algorithm: Ravelin3DS.JWKThumbprintAlgorithm = .SHA256) throws -> Ravelin3DS.ECPrivateKey
}
public typealias ECKeyPair = Ravelin3DS.ECPrivateKey
extension Swift.UInt32 {
  @_specialize(exported: false, kind: full, where T == Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init<T>(bytes: T, fromIndex index: T.Index) where T : Swift.Collection, T.Element == Swift.UInt8, T.Index == Swift.Int {
    if bytes.isEmpty {
      self = 0
      return
    }

    let count = bytes.count

    let val0 = count > 0 ? UInt32(bytes[index.advanced(by: 0)]) << 24 : 0
    let val1 = count > 1 ? UInt32(bytes[index.advanced(by: 1)]) << 16 : 0
    let val2 = count > 2 ? UInt32(bytes[index.advanced(by: 2)]) << 8 : 0
    let val3 = count > 3 ? UInt32(bytes[index.advanced(by: 3)]) : 0

    self = val0 | val1 | val2 | val3
  }
}
extension Ravelin3DS.ChaCha20 {
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
public struct OFB : Ravelin3DS.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: Ravelin3DS.OFB.Error, b: Ravelin3DS.OFB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: Ravelin3DS.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping Ravelin3DS.CipherOperationOnBlock, encryptionOperation: @escaping Ravelin3DS.CipherOperationOnBlock) throws -> Ravelin3DS.CipherModeWorker
}
extension Foundation.Data {
  public init?(base64URLEncoded base64URLString: Swift.String)
  public init?(base64URLEncoded base64URLData: Foundation.Data)
  public func base64URLEncodedString() -> Swift.String
  public func base64URLEncodedData() -> Foundation.Data
}
extension Foundation.Data : Ravelin3DS.DataConvertible {
  public init(_ data: Foundation.Data)
  public func data() -> Foundation.Data
}
extension Foundation.Data : Ravelin3DS.ExpressibleAsSymmetricKeyComponents {
  public static func representing(symmetricKeyComponents components: Ravelin3DS.SymmetricKeyComponents) throws -> Foundation.Data
  public func symmetricKeyComponents() throws -> Ravelin3DS.SymmetricKeyComponents
}
@objc(R3DS2AuthenticationRequestParameters) @objcMembers public class R3DS2AuthenticationRequestParameters : ObjectiveC.NSObject {
  @objc public init(sdkTransactionId: Swift.String, deviceData: Swift.String, sdkEphemeralPublicKey: Swift.String, sdkAppId: Swift.String, sdkReferenceNumber: Swift.String, messageVersion: Swift.String) throws
  @objc public func getDeviceData() -> Swift.String
  @objc public func getSDKTransactionId() -> Swift.String
  @objc public func getSDKAppID() -> Swift.String
  @objc public func getSDKReferenceNumber() -> Swift.String
  @objc public func getSDKEphemeralPublicKey() -> Swift.String
  @objc public func getMessageVersion() -> Swift.String
  @objc deinit
}
public struct CFB : Ravelin3DS.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: Ravelin3DS.CFB.Error, b: Ravelin3DS.CFB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum SegmentSize : Swift.Int {
    case cfb8
    case cfb128
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public let options: Ravelin3DS.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>, segmentSize: Ravelin3DS.CFB.SegmentSize = .cfb128)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping Ravelin3DS.CipherOperationOnBlock, encryptionOperation: @escaping Ravelin3DS.CipherOperationOnBlock) throws -> Ravelin3DS.CipherModeWorker
}
@_inheritsConvenienceInitializers @objc(R3DS2TextBoxCustomization) @objcMembers public class R3DS2TextBoxCustomization : Ravelin3DS.R3DS2Customization {
  @objc public func setBorderWidth(borderWidth: Swift.Int) throws
  @objc public func setBorderColor(hexColorCode: Swift.String) throws
  @objc public func setDarkBorderColor(hexColorCode: Swift.String) throws
  @objc public func setCornerRadius(cornerRadius: Swift.Int) throws
  @objc public func getBorderWidth() -> Swift.Int
  @objc public func getBorderColor() -> Swift.String
  @objc public func getDarkBorderColor() -> Swift.String
  @objc public func getCornerRadius() -> Swift.Int
  @objc override public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  @objc override dynamic public init()
  @objc deinit
}
extension Swift.UInt64 {
  @_specialize(exported: false, kind: full, where T == Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init<T>(bytes: T, fromIndex index: T.Index) where T : Swift.Collection, T.Element == Swift.UInt8, T.Index == Swift.Int {
    if bytes.isEmpty {
      self = 0
      return
    }

    let count = bytes.count

    let val0 = count > 0 ? UInt64(bytes[index.advanced(by: 0)]) << 56 : 0
    let val1 = count > 1 ? UInt64(bytes[index.advanced(by: 1)]) << 48 : 0
    let val2 = count > 2 ? UInt64(bytes[index.advanced(by: 2)]) << 40 : 0
    let val3 = count > 3 ? UInt64(bytes[index.advanced(by: 3)]) << 32 : 0
    let val4 = count > 4 ? UInt64(bytes[index.advanced(by: 4)]) << 24 : 0
    let val5 = count > 5 ? UInt64(bytes[index.advanced(by: 5)]) << 16 : 0
    let val6 = count > 6 ? UInt64(bytes[index.advanced(by: 6)]) << 8 : 0
    let val7 = count > 7 ? UInt64(bytes[index.advanced(by: 7)]) : 0

    self = val0 | val1 | val2 | val3 | val4 | val5 | val6 | val7
  }
}
final public class OCB : Ravelin3DS.BlockMode {
  public enum Mode {
    case combined
    case detached
    public static func == (a: Ravelin3DS.OCB.Mode, b: Ravelin3DS.OCB.Mode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let options: Ravelin3DS.BlockModeOption
  public enum Error : Swift.Error {
    case invalidNonce
    case fail
    public static func == (a: Ravelin3DS.OCB.Error, b: Ravelin3DS.OCB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let customBlockSize: Swift.Int?
  final public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(nonce N: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, tagLength: Swift.Int = 16, mode: Ravelin3DS.OCB.Mode = .detached)
  @inlinable convenience public init(nonce N: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, mode: Ravelin3DS.OCB.Mode = .detached) {
    self.init(nonce: N, additionalAuthenticatedData: additionalAuthenticatedData, tagLength: authenticationTag.count, mode: mode)
    self.authenticationTag = authenticationTag
  }
  final public func worker(blockSize: Swift.Int, cipherOperation: @escaping Ravelin3DS.CipherOperationOnBlock, encryptionOperation: @escaping Ravelin3DS.CipherOperationOnBlock) throws -> Ravelin3DS.CipherModeWorker
  @objc deinit
}
final public class SHA2 {
  @usableFromInline
  final internal let variant: Ravelin3DS.SHA2.Variant
  @usableFromInline
  final internal let size: Swift.Int
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal let digestLength: Swift.Int
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var processedBytesTotalCount: Swift.Int
  @usableFromInline
  final internal var accumulatedHash32: [Swift.UInt32]
  @usableFromInline
  final internal var accumulatedHash64: [Swift.UInt64]
  @frozen public enum Variant : Swift.RawRepresentable {
    case sha224, sha256, sha384, sha512
    public var digestLength: Swift.Int {
      get
    }
    public var blockSize: Swift.Int {
      get
    }
    public typealias RawValue = Swift.Int
    public var rawValue: Ravelin3DS.SHA2.Variant.RawValue {
      get
    }
    public init?(rawValue: Ravelin3DS.SHA2.Variant.RawValue)
    @usableFromInline
    internal var h: Swift.Array<Swift.UInt64> {
      get
    }
    @usableFromInline
    internal var finalLength: Swift.Int {
      get
    }
  }
  public init(variant: Ravelin3DS.SHA2.Variant)
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  @usableFromInline
  final internal func process64(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.Array<Swift.UInt64>)
  @usableFromInline
  final internal func process32(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.Array<Swift.UInt32>)
  @objc deinit
}
extension Ravelin3DS.SHA2 : Ravelin3DS.Updatable {
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      let lengthInBits = (processedBytesTotalCount + self.accumulated.count) * 8
      let lengthBytes = lengthInBits.bytes(totalBytes: self.blockSize / 8) // A 64-bit/128-bit representation of b. blockSize fit by accident.

      // Step 1. Append padding
      bitPadding(to: &self.accumulated, blockSize: self.blockSize, allowance: self.blockSize / 8)

      // Step 2. Append Length a 64-bit representation of lengthInBits
      self.accumulated += lengthBytes
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: self.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= self.blockSize {
        switch self.variant {
          case .sha224, .sha256:
            self.process32(block: chunk, currentHash: &self.accumulatedHash32)
          case .sha384, .sha512:
            self.process64(block: chunk, currentHash: &self.accumulatedHash64)
          }
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)
    self.processedBytesTotalCount += processedBytes

    // output current hash
    var result = Array<UInt8>(repeating: 0, count: variant.digestLength)
    switch self.variant {
      case .sha224, .sha256:
        var pos = 0
        for idx in 0..<self.accumulatedHash32.count where idx < self.variant.finalLength {
          let h = accumulatedHash32[idx]
          result[pos + 0] = UInt8((h >> 24) & 0xff)
          result[pos + 1] = UInt8((h >> 16) & 0xff)
          result[pos + 2] = UInt8((h >> 8) & 0xff)
          result[pos + 3] = UInt8(h & 0xff)
          pos += 4
        }
      case .sha384, .sha512:
        var pos = 0
        for idx in 0..<self.accumulatedHash64.count where idx < self.variant.finalLength {
          let h = accumulatedHash64[idx]
          result[pos + 0] = UInt8((h >> 56) & 0xff)
          result[pos + 1] = UInt8((h >> 48) & 0xff)
          result[pos + 2] = UInt8((h >> 40) & 0xff)
          result[pos + 3] = UInt8((h >> 32) & 0xff)
          result[pos + 4] = UInt8((h >> 24) & 0xff)
          result[pos + 5] = UInt8((h >> 16) & 0xff)
          result[pos + 6] = UInt8((h >> 8) & 0xff)
          result[pos + 7] = UInt8(h & 0xff)
          pos += 8
        }
    }

    // reset hash value for instance
    if isLast {
      switch self.variant {
        case .sha224, .sha256:
          self.accumulatedHash32 = self.variant.h.lazy.map { UInt32($0) } // FIXME: UInt64 for process64
        case .sha384, .sha512:
          self.accumulatedHash64 = self.variant.h
      }
    }

    return result
  }
}
public protocol CompactSerializable {
  func serialize(to serializer: inout Ravelin3DS.CompactSerializer)
}
public protocol CompactSerializer {
  var components: [Ravelin3DS.DataConvertible] { get }
  mutating func serialize<T>(_ object: T) where T : Ravelin3DS.DataConvertible
}
public struct JOSESerializer {
  public func serialize<T>(compact object: T) -> Swift.String where T : Ravelin3DS.CompactSerializable
}
final public class Scrypt {
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, dkLen: Swift.Int, N: Swift.Int, r: Swift.Int, p: Swift.Int) throws
  final public func calculate() throws -> [Swift.UInt8]
  @objc deinit
}
public struct Decrypter {
  public init?<KeyType>(keyManagementAlgorithm: Ravelin3DS.KeyManagementAlgorithm, contentEncryptionAlgorithm: Ravelin3DS.ContentEncryptionAlgorithm, decryptionKey: KeyType)
}
extension Ravelin3DS.Decrypter {
  @available(*, deprecated, message: "Use `init?(keyManagementAlgorithm:contentEncryptionAlgorithm:decryptionKey:)` instead")
  public init?<KeyType>(keyDecryptionAlgorithm: Ravelin3DS.AsymmetricKeyAlgorithm, decryptionKey key: KeyType, contentDecryptionAlgorithm: Ravelin3DS.SymmetricKeyAlgorithm)
  @available(*, deprecated, message: "Use `init?(keyManagementAlgorithm:contentEncryptionAlgorithm:decryptionKey:)` instead")
  public init?<KeyType>(keyDecryptionAlgorithm: Ravelin3DS.AsymmetricKeyAlgorithm, keyDecryptionKey kdk: KeyType, contentDecryptionAlgorithm: Ravelin3DS.SymmetricKeyAlgorithm)
}
@available(*, deprecated, message: "This type will be removed with the next major release.")
public struct DecryptionContext {
}
@available(*, deprecated, message: "This type will be removed with the next major release.")
public struct SymmetricDecryptionContext {
}
@objc(R3DS2ChallengeStatusReceiver) public protocol R3DS2ChallengeStatusReceiver {
  @objc func completed(completionEvent: Ravelin3DS.R3DS2CompletionEvent)
  @objc func cancelled()
  @objc func timedout()
  @objc func protocolError(protocolErrorEvent: Ravelin3DS.R3DS2ProtocolErrorEvent)
  @objc func runtimeError(runtimeErrorEvent: Ravelin3DS.R3DS2RuntimeErrorEvent)
}
@objc(R3DS2RuntimeErrorEvent) @objcMembers public class R3DS2RuntimeErrorEvent : ObjectiveC.NSObject {
  @objc public init(_ errorCode: Swift.String?, _ errorMessage: Swift.String)
  @objc public func getErrorCode() -> Swift.String?
  @objc public func getErrorMessage() -> Swift.String
  @objc deinit
}
@objc(R3DS2ErrorMessage) @objcMembers public class R3DS2ErrorMessage : ObjectiveC.NSObject {
  @objc public init(transactionID: Swift.String, errorCode: Swift.String, errorComponent: Swift.String, errorDescription: Swift.String, errorDetail: Swift.String, errorMessageType: Swift.String?, messageVersionNumber: Swift.String)
  @objc public func getTransactionID() -> Swift.String
  @objc public func getErrorCode() -> Swift.String
  @objc public func getErrorComponent() -> Swift.String
  @objc public func getErrorDescription() -> Swift.String
  @objc public func getErrorDetail() -> Swift.String
  @objc public func getErrorMessageType() -> Swift.String
  @objc public func getMessageVersionNumber() -> Swift.String
  @objc deinit
}
@objc(R3DS2ProtocolErrorEvent) @objcMembers public class R3DS2ProtocolErrorEvent : ObjectiveC.NSObject {
  @objc public init(_ sdkTransactionID: Swift.String, _ errorMessage: Ravelin3DS.R3DS2ErrorMessage)
  @objc public func getErrorMessage() -> Ravelin3DS.R3DS2ErrorMessage
  @objc public func getSDKTransactionID() -> Swift.String
  @objc deinit
}
@objc(R3DS2CompletionEvent) @objcMembers public class R3DS2CompletionEvent : ObjectiveC.NSObject {
  @objc public init(_ sdkTransactionID: Swift.String, _ transactionStatus: Swift.String)
  @objc public func getSDKTransactionID() -> Swift.String
  @objc public func getTransactionStatus() -> Swift.String
  @objc deinit
}
@usableFromInline
final internal class StreamDecryptor : Ravelin3DS.Cryptor, Ravelin3DS.Updatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal var worker: Ravelin3DS.CipherModeWorker
  @usableFromInline
  final internal let padding: Ravelin3DS.Padding
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var lastBlockRemainder: Swift.Int
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: Ravelin3DS.Padding, _ worker: Ravelin3DS.CipherModeWorker) throws
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    let toProcess = self.accumulated.prefix(max(self.accumulated.count - self.worker.additionalBufferSize, 0))

    if var finalizingWorker = worker as? FinalizingDecryptModeWorker, isLast == true {
      // will truncate suffix if needed
      try finalizingWorker.willDecryptLast(bytes: self.accumulated.slice)
    }

    var processedBytesCount = 0
    var plaintext = Array<UInt8>(reserveCapacity: bytes.count + self.worker.additionalBufferSize)
    for chunk in toProcess.batched(by: self.blockSize) {
      plaintext += self.worker.decrypt(block: chunk)
      processedBytesCount += chunk.count
    }

    if var finalizingWorker = worker as? FinalizingDecryptModeWorker, isLast == true {
      plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
    }

    // omit unecessary calculation if not needed
    if self.padding != .noPadding {
      self.lastBlockRemainder = plaintext.count.quotientAndRemainder(dividingBy: self.blockSize).remainder
    }

    if isLast {
      // CTR doesn't need padding. Really. Add padding to the last block if really want. but... don't.
      plaintext = self.padding.remove(from: plaintext, blockSize: self.blockSize - self.lastBlockRemainder)
    }

    self.accumulated.removeFirst(processedBytesCount) // super-slow

    if var finalizingWorker = worker as? FinalizingDecryptModeWorker, isLast == true {
      plaintext = Array(try finalizingWorker.finalize(decrypt: plaintext.slice))
    }

    return plaintext
  }
  @inlinable final public func seek(to position: Swift.Int) throws {
    guard var worker = self.worker as? SeekableModeWorker else {
      fatalError("Not supported")
    }

    try worker.seek(to: position)
    self.worker = worker
  }
  @objc @usableFromInline
  deinit
}
extension Ravelin3DS.PKCS5 {
  public struct PBKDF2 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: Ravelin3DS.PKCS5.PBKDF2.Error, b: Ravelin3DS.PKCS5.PBKDF2.Error) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil, variant: Ravelin3DS.HMAC.Variant = .sha256) throws
    public func calculate() throws -> Swift.Array<Swift.UInt8>
  }
}
@_specialize(exported: false, kind: full, where T == Swift.Int)
@_specialize(exported: false, kind: full, where T == Swift.UInt)
@_specialize(exported: false, kind: full, where T == Swift.UInt8)
@_specialize(exported: false, kind: full, where T == Swift.UInt16)
@_specialize(exported: false, kind: full, where T == Swift.UInt32)
@_specialize(exported: false, kind: full, where T == Swift.UInt64)
@inlinable internal func arrayOfBytes<T>(value: T, length totalBytes: Swift.Int = MemoryLayout<T>.size) -> Swift.Array<Swift.UInt8> where T : Swift.FixedWidthInteger {
  let valuePointer = UnsafeMutablePointer<T>.allocate(capacity: 1)
  valuePointer.pointee = value

  let bytesPointer = UnsafeMutablePointer<UInt8>(OpaquePointer(valuePointer))
  var bytes = Array<UInt8>(repeating: 0, count: totalBytes)
  for j in 0..<min(MemoryLayout<T>.size, totalBytes) {
    bytes[totalBytes - 1 - j] = (bytesPointer + j).pointee
  }

  valuePointer.deinitialize(count: 1)
  valuePointer.deallocate()

  return bytes
}
@objc(R3DS2Service) public protocol R3DS2Service {
  @objc func initialize(configParameters: Ravelin3DS.R3DS2ConfigParameters, locale: Swift.String?, uiCustomization: Ravelin3DS.R3DS2UiCustomization?) throws
  @objc func initialize(configParameters: Ravelin3DS.R3DS2ConfigParameters, locale: Swift.String?, uiCustomization: Ravelin3DS.R3DS2UiCustomization?, completion: ((Swift.Bool) -> Swift.Void)?) throws
  @objc func createTransaction(directoryServerID: Swift.String, messageVersion: Swift.String?) throws -> Ravelin3DS.R3DS2Transaction
  @objc func getWarnings() throws -> [Ravelin3DS.R3DS2Warning]
  @objc func getSDKVersion() throws -> Swift.String
  @objc func cleanup() throws
}
@_inheritsConvenienceInitializers @objc(R3DS2ServiceSDK) public class R3DS2ServiceSDK : ObjectiveC.NSObject, Ravelin3DS.R3DS2Service {
  @objc override dynamic public init()
  @objc public init(bundle: Foundation.Bundle)
  @objc public func initialize(configParameters: Ravelin3DS.R3DS2ConfigParameters, locale: Swift.String?, uiCustomization: Ravelin3DS.R3DS2UiCustomization?, completion: ((Swift.Bool) -> Swift.Void)?) throws
  @objc public func initialize(configParameters: Ravelin3DS.R3DS2ConfigParameters, locale: Swift.String?, uiCustomization: Ravelin3DS.R3DS2UiCustomization?) throws
  @objc public func createTransaction(directoryServerID directoryServerId: Swift.String, messageVersion: Swift.String?) throws -> Ravelin3DS.R3DS2Transaction
  @objc public func getWarnings() throws -> [Ravelin3DS.R3DS2Warning]
  @objc public func getSDKVersion() throws -> Swift.String
  @objc public func cleanup() throws
  @objc deinit
}
extension Swift.FixedWidthInteger {
  @inlinable internal func bytes(totalBytes: Swift.Int = MemoryLayout<Self>.size) -> Swift.Array<Swift.UInt8> {
    arrayOfBytes(value: self.littleEndian, length: totalBytes)
    // TODO: adjust bytes order
    // var value = self.littleEndian
    // return withUnsafeBytes(of: &value, Array.init).reversed()
  }
}
public protocol Cryptors : AnyObject {
  func makeEncryptor() throws -> Ravelin3DS.Cryptor & Ravelin3DS.Updatable
  func makeDecryptor() throws -> Ravelin3DS.Cryptor & Ravelin3DS.Updatable
  static func randomIV(_ blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
}
extension Ravelin3DS.Cryptors {
  public static func randomIV(_ count: Swift.Int) -> Swift.Array<Swift.UInt8>
}
public struct BlockModeOption : Swift.OptionSet {
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  @usableFromInline
  internal static let none: Ravelin3DS.BlockModeOption
  @usableFromInline
  internal static let initializationVectorRequired: Ravelin3DS.BlockModeOption
  @usableFromInline
  internal static let paddingRequired: Ravelin3DS.BlockModeOption
  @usableFromInline
  internal static let useEncryptToDecrypt: Ravelin3DS.BlockModeOption
  public typealias ArrayLiteralElement = Ravelin3DS.BlockModeOption
  public typealias Element = Ravelin3DS.BlockModeOption
  public typealias RawValue = Swift.Int
}
public struct JWKSet {
  public let keys: [Ravelin3DS.JWK]
  public init(keys: [Ravelin3DS.JWK])
  public init(data: Foundation.Data) throws
  public func jsonString() -> Swift.String?
  public func jsonData() -> Foundation.Data?
}
extension Ravelin3DS.JWKSet : Swift.Collection {
  public typealias ArrayType = [Ravelin3DS.JWK]
  public typealias Element = Ravelin3DS.JWKSet.ArrayType.Element
  public typealias Index = Ravelin3DS.JWKSet.ArrayType.Index
  public typealias Iterator = Ravelin3DS.JWKSet.ArrayType.Iterator
  public var startIndex: Ravelin3DS.JWKSet.Index {
    get
  }
  public var endIndex: Ravelin3DS.JWKSet.Index {
    get
  }
  public subscript(index: Ravelin3DS.JWKSet.Index) -> Ravelin3DS.JWKSet.Element {
    get
  }
  public func index(after index: Ravelin3DS.JWKSet.Index) -> Ravelin3DS.JWKSet.Index
  public func makeIterator() -> Swift.IndexingIterator<Ravelin3DS.JWKSet.ArrayType>
  public typealias Indices = Swift.DefaultIndices<Ravelin3DS.JWKSet>
  public typealias SubSequence = Swift.Slice<Ravelin3DS.JWKSet>
}
extension Ravelin3DS.JWKSet : Swift.ExpressibleByArrayLiteral {
  public typealias ArrayLiteralElement = Ravelin3DS.JWKSet.Element
  public init(arrayLiteral elements: Ravelin3DS.JWKSet.ArrayLiteralElement...)
}
extension Ravelin3DS.SignatureAlgorithm : Swift.Equatable {}
extension Ravelin3DS.SignatureAlgorithm : Swift.Hashable {}
extension Ravelin3DS.SignatureAlgorithm : Swift.RawRepresentable {}
extension Ravelin3DS.KeyManagementAlgorithm : Swift.Equatable {}
extension Ravelin3DS.KeyManagementAlgorithm : Swift.Hashable {}
extension Ravelin3DS.KeyManagementAlgorithm : Swift.RawRepresentable {}
extension Ravelin3DS.JWKThumbprintAlgorithm : Swift.Equatable {}
extension Ravelin3DS.JWKThumbprintAlgorithm : Swift.Hashable {}
extension Ravelin3DS.JWKThumbprintAlgorithm : Swift.RawRepresentable {}
extension Ravelin3DS.ContentEncryptionAlgorithm : Swift.Equatable {}
extension Ravelin3DS.ContentEncryptionAlgorithm : Swift.Hashable {}
extension Ravelin3DS.ContentEncryptionAlgorithm : Swift.RawRepresentable {}
extension Ravelin3DS.CTR : Ravelin3DS.BlockMode {}
extension Ravelin3DS.CTR.Error : Swift.Equatable {}
extension Ravelin3DS.CTR.Error : Swift.Hashable {}
extension Ravelin3DS.CipherError : Swift.Equatable {}
extension Ravelin3DS.CipherError : Swift.Hashable {}
extension Ravelin3DS.JWKParameter : Swift.Equatable {}
extension Ravelin3DS.JWKParameter : Swift.Hashable {}
extension Ravelin3DS.JWKParameter : Swift.RawRepresentable {}
extension Ravelin3DS.RSAParameter : Swift.Equatable {}
extension Ravelin3DS.RSAParameter : Swift.Hashable {}
extension Ravelin3DS.RSAParameter : Swift.RawRepresentable {}
extension Ravelin3DS.SymmetricKeyParameter : Swift.Equatable {}
extension Ravelin3DS.SymmetricKeyParameter : Swift.Hashable {}
extension Ravelin3DS.SymmetricKeyParameter : Swift.RawRepresentable {}
extension Ravelin3DS.ECParameter : Swift.Equatable {}
extension Ravelin3DS.ECParameter : Swift.Hashable {}
extension Ravelin3DS.ECParameter : Swift.RawRepresentable {}
extension Ravelin3DS.HMACAlgorithm : Swift.Equatable {}
extension Ravelin3DS.HMACAlgorithm : Swift.Hashable {}
extension Ravelin3DS.HMACAlgorithm : Swift.RawRepresentable {}
extension Ravelin3DS.CompressionAlgorithm : Swift.Equatable {}
extension Ravelin3DS.CompressionAlgorithm : Swift.Hashable {}
extension Ravelin3DS.CompressionAlgorithm : Swift.RawRepresentable {}
extension Ravelin3DS.JWEHeader : Ravelin3DS.DataConvertible {}
extension Ravelin3DS.Blowfish.Error : Swift.Equatable {}
extension Ravelin3DS.Blowfish.Error : Swift.Hashable {}
extension Ravelin3DS.AES.Error : Swift.Equatable {}
extension Ravelin3DS.AES.Error : Swift.Hashable {}
extension Ravelin3DS.AES.Variant : Swift.Equatable {}
extension Ravelin3DS.AES.Variant : Swift.Hashable {}
extension Ravelin3DS.AES.Variant : Swift.RawRepresentable {}
extension Ravelin3DS.SHA3.Variant : Swift.Equatable {}
extension Ravelin3DS.SHA3.Variant : Swift.Hashable {}
extension Ravelin3DS.CMAC.Error : Swift.Equatable {}
extension Ravelin3DS.CMAC.Error : Swift.Hashable {}
extension Ravelin3DS.Bit : Swift.Equatable {}
extension Ravelin3DS.Bit : Swift.Hashable {}
extension Ravelin3DS.Bit : Swift.RawRepresentable {}
extension Ravelin3DS.ECCurveType : Swift.Equatable {}
extension Ravelin3DS.ECCurveType : Swift.Hashable {}
extension Ravelin3DS.ECCurveType : Swift.RawRepresentable {}
extension Ravelin3DS.ECCompression : Swift.Equatable {}
extension Ravelin3DS.ECCompression : Swift.Hashable {}
extension Ravelin3DS.ECCompression : Swift.RawRepresentable {}
extension Ravelin3DS.CBC.Error : Swift.Equatable {}
extension Ravelin3DS.CBC.Error : Swift.Hashable {}
extension Ravelin3DS.PKCS5.PBKDF1.Error : Swift.Equatable {}
extension Ravelin3DS.PKCS5.PBKDF1.Error : Swift.Hashable {}
extension Ravelin3DS.PKCS5.PBKDF1.Variant : Swift.Equatable {}
extension Ravelin3DS.PKCS5.PBKDF1.Variant : Swift.Hashable {}
extension Ravelin3DS.JWKKeyType : Swift.Equatable {}
extension Ravelin3DS.JWKKeyType : Swift.Hashable {}
extension Ravelin3DS.JWKKeyType : Swift.RawRepresentable {}
extension Ravelin3DS.Poly1305.Error : Swift.Equatable {}
extension Ravelin3DS.Poly1305.Error : Swift.Hashable {}
extension Ravelin3DS.GCM.Mode : Swift.Equatable {}
extension Ravelin3DS.GCM.Mode : Swift.Hashable {}
extension Ravelin3DS.GCM.Error : Swift.Equatable {}
extension Ravelin3DS.GCM.Error : Swift.Hashable {}
extension Ravelin3DS.JWSHeader : Ravelin3DS.DataConvertible {}
extension Ravelin3DS.HMAC.Error : Swift.Equatable {}
extension Ravelin3DS.HMAC.Error : Swift.Hashable {}
extension Ravelin3DS.HMAC.Variant : Swift.Equatable {}
extension Ravelin3DS.HMAC.Variant : Swift.Hashable {}
extension Ravelin3DS.HKDF.Error : Swift.Equatable {}
extension Ravelin3DS.HKDF.Error : Swift.Hashable {}
extension Ravelin3DS.CCM : Ravelin3DS.BlockMode {}
extension Ravelin3DS.CCM.Error : Swift.Equatable {}
extension Ravelin3DS.CCM.Error : Swift.Hashable {}
extension Ravelin3DS.Rabbit.Error : Swift.Equatable {}
extension Ravelin3DS.Rabbit.Error : Swift.Hashable {}
extension Ravelin3DS.PCBC.Error : Swift.Equatable {}
extension Ravelin3DS.PCBC.Error : Swift.Hashable {}
extension Ravelin3DS.ChaCha20.Error : Swift.Equatable {}
extension Ravelin3DS.ChaCha20.Error : Swift.Hashable {}
extension Ravelin3DS.Padding : Swift.Equatable {}
extension Ravelin3DS.Padding : Swift.Hashable {}
extension Ravelin3DS.OFB.Error : Swift.Equatable {}
extension Ravelin3DS.OFB.Error : Swift.Hashable {}
extension Ravelin3DS.CFB.Error : Swift.Equatable {}
extension Ravelin3DS.CFB.Error : Swift.Hashable {}
extension Ravelin3DS.CFB.SegmentSize : Swift.Equatable {}
extension Ravelin3DS.CFB.SegmentSize : Swift.Hashable {}
extension Ravelin3DS.CFB.SegmentSize : Swift.RawRepresentable {}
extension Ravelin3DS.OCB.Mode : Swift.Equatable {}
extension Ravelin3DS.OCB.Mode : Swift.Hashable {}
extension Ravelin3DS.OCB.Error : Swift.Equatable {}
extension Ravelin3DS.OCB.Error : Swift.Hashable {}
extension Ravelin3DS.SHA2.Variant : Swift.Equatable {}
extension Ravelin3DS.SHA2.Variant : Swift.Hashable {}
extension Ravelin3DS.SHA2.Variant : Swift.Sendable {}
extension Ravelin3DS.PKCS5.PBKDF2.Error : Swift.Equatable {}
extension Ravelin3DS.PKCS5.PBKDF2.Error : Swift.Hashable {}
